<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wrongful Dismissal Timeline - Case Evidence</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* CSS Variables for Theming */
    :root {
      /* Light mode colors (default) */
      --bg-primary: #f4f6f8;
      --bg-secondary: #ffffff;
      --bg-card: #ffffff;
      --text-primary: #333;
      --text-secondary: #666;
      --text-tertiary: #999;
      --border-color: #ddd;
      --border-hover: #999;
      --timeline-line: #ccc;
      --header-text: #1a1a1a;
      --btn-hover-bg: #f5f5f5;
      --panel-overlay: rgba(0, 0, 0, 0.5);
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.15);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.3);
      --month-label-bg: #ffffff;
      --month-label-text: #333;
      --month-tick-color: #666;
    }

    [data-theme="dark"] {
      /* Dark mode colors */
      --bg-primary: #1e1e1e;
      --bg-secondary: #2b2b2b;
      --bg-card: #3a3a3a;
      --text-primary: #e0e0e0;
      --text-secondary: #b0b0b0;
      --text-tertiary: #808080;
      --border-color: #404040;
      --border-hover: #606060;
      --timeline-line: #555;
      --header-text: #f0f0f0;
      --btn-hover-bg: #3a3a3a;
      --panel-overlay: rgba(0, 0, 0, 0.7);
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.4);
      --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.5);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.6);
      --month-label-bg: transparent;
      --month-label-text: #ffffff;
      --month-tick-color: #999;
    }

    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      font-size: 14px;
      background: var(--bg-primary);
      color: var(--text-primary);
      padding: 40px 10px;
      transition: background-color 0.3s ease, color 0.3s ease;
      overflow-x: hidden;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
      padding: 0 10px;
    }

    /* Header */
    .header {
      text-align: center;
      margin-bottom: 60px;
    }

    .header h1 {
      font-size: 32px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--header-text);
    }

    .header .subtitle {
      color: var(--text-secondary);
      font-size: 16px;
      margin-bottom: 20px;
    }

    .controls {
      margin-top: 30px;
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    .view-btn {
      padding: 10px 20px;
      border: 2px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .view-btn:hover {
      border-color: var(--border-hover);
      background: var(--btn-hover-bg);
    }

    .view-btn.active {
      background: #3498db;
      border-color: #3498db;
      color: white;
    }

    /* Lateness Sub-Filters */
    .lateness-subfilters {
      display: none; /* Hidden by default */
      gap: 8px;
      margin-top: 12px;
      padding: 0;
      align-items: center;
      justify-content: center;
    }

    .lateness-subfilters.visible {
      display: flex;
    }

    .lateness-label {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-right: 4px;
    }

    .lateness-btn {
      padding: 8px 14px;
      border: 2px solid var(--border-color);
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-size: 13px;
      font-weight: 600;
      color: white;
    }

    .lateness-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
    }

    /* Employee button - Blue */
    .lateness-btn[data-person="employee"] {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    }

    /* Boss/Coworker button - Orange/Red */
    .lateness-btn[data-person="boss-coworker"] {
      background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
    }

    /* Active state - brighter border and slight glow */
    .lateness-btn.active {
      border-color: #fff;
      box-shadow: 0 0 12px currentColor, 0 4px 8px rgba(0, 0, 0, 0.3);
      transform: translateY(-1px);
    }

    .lateness-btn[data-person="employee"].active {
      box-shadow: 0 0 12px #3498db, 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .lateness-btn[data-person="boss-coworker"].active {
      box-shadow: 0 0 12px #e67e22, 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    /* Inactive state - grayed out */
    .lateness-btn:not(.active) {
      opacity: 0.5;
      filter: grayscale(50%);
    }

    /* Dark mode adjustments */
    [data-theme="dark"] .lateness-btn {
      border-color: var(--border-color);
    }

    [data-theme="dark"] .lateness-btn.active {
      border-color: #fff;
    }

    /* Timeline Container */
    .timeline-wrapper {
      position: relative;
      padding: 100px 5px;
      min-height: 800px;
      overflow-x: hidden;
      overflow-y: auto;
    }

    /* Timeline Line */
    .timeline-line {
      stroke: var(--timeline-line);
      stroke-width: 2;
      stroke-dasharray: 5, 5;
    }

    /* Timeline Circles */
    .timeline-dot {
      cursor: pointer;
      transition: all 0.2s;
      stroke-width: 2;
      stroke: white;
    }

    /* Priority-based borders - Light Mode */
    .timeline-dot.priority-nuclear {
      stroke-width: 2;
      stroke: #fff;
      filter: drop-shadow(0 0 3px rgba(255, 0, 0, 0.6));
      animation: nuclear-pulse 3.5s ease-in-out infinite;
      transform-origin: center;
      transform-box: fill-box;
    }

    @keyframes nuclear-pulse {
      0%, 100% {
        filter: drop-shadow(0 0 3px rgba(255, 0, 0, 0.6));
      }
      50% {
        filter: drop-shadow(0 0 6px rgba(255, 0, 0, 0.8));
      }
    }

    .timeline-dot.priority-critical {
      stroke-width: 2;
      stroke: #000;
    }

    /* Priority-based borders - Dark Mode (reversed for better visibility) */
    [data-theme="dark"] .timeline-dot {
      stroke: #000;  /* Default: black border for medium priority */
    }

    [data-theme="dark"] .timeline-dot.priority-nuclear {
      stroke: #fff;  /* White border for nuclear (most important) */
      animation: nuclear-pulse-dark 3.5s ease-in-out infinite;
    }

    @keyframes nuclear-pulse-dark {
      0%, 100% {
        filter: drop-shadow(0 0 3px rgba(255, 140, 0, 0.9));  /* Orange */
      }
      50% {
        filter: drop-shadow(0 0 6px rgba(255, 165, 0, 1));  /* Brighter orange at peak */
      }
    }

    [data-theme="dark"] .timeline-dot.priority-critical {
      stroke: #fff;  /* White border for critical (important) */
    }

    .timeline-dot:hover {
      r: 12;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
    }

    [data-theme="dark"] .timeline-dot:hover {
      filter: drop-shadow(0 2px 8px rgba(255,255,255,0.4));
    }

    .timeline-dot.highlighted {
      filter: drop-shadow(0 0 4px currentColor);
    }

    [data-theme="dark"] .timeline-dot.highlighted {
      filter: drop-shadow(0 0 6px currentColor);
    }

    /* Range Event Bars */
    .range-bar {
      cursor: pointer;
      transition: all 0.2s;
      opacity: 0.8;
      stroke-width: 2;
    }

    .range-bar:hover {
      opacity: 1;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
    }

    /* Event Cards Container */
    .cards-container {
      position: absolute;
      top: 0;
      left: 20px;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Event Cards */
    .event-card {
      position: absolute;
      width: 280px;
      background: var(--bg-card);
      border-radius: 8px;
      box-shadow: var(--shadow-sm);
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: all;
      z-index: 10;
    }

    .event-card:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
      z-index: 100;
    }

    .event-card.highlight {
      background: #fff8dc;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.4);
      transition: all 0.1s ease-out;
    }

    [data-theme="dark"] .event-card.highlight {
      background: #4a4a4a;
    }

    /* Connecting Line from Card to Dot */
    .connector-line {
      stroke: #666;
      stroke-width: 2.5;
      transition: stroke 0.2s ease, stroke-width 0.2s ease, filter 0.2s ease;
    }

    .connector-line.highlighted {
      stroke-width: 3.5;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
    }

    /* Card Content */
    .card-date {
      font-size: 18px;
      font-weight: 800;
      margin-bottom: 6px;
      line-height: 1.2;
    }

    .card-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 6px;
      min-height: 20px;
    }

    .tag-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 600;
      color: white;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .tag-critical { background: #dc2626; }
    .tag-smoking-gun { background: #991b1b; }
    .tag-family { background: #db2777; }
    .tag-ohs { background: #ea580c; }
    .tag-disability { background: #eab308; color: #1f2937; }
    .tag-wrongful-dismissal { background: #2563eb; }
    .tag-correspondence { background: #059669; }
    .tag-bad-faith-conduct { background: #7c2d12; color: #ffffff; }
    .tag-just-cause-failure { background: #7c3aed; }
    .tag-post-termination-misconduct { background: #0891b2; }
    .tag-lateness-employee { background: #6b7280; }
    .tag-lateness-boss { background: #4b5563; }
    .tag-lateness-coworker { background: #9ca3af; color: #1f2937; }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 5px;
      color: var(--text-primary);
      line-height: 1.3;
    }

    .card-description {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* Priority indicators */
    .priority-nuclear .timeline-dot,
    .priority-critical .timeline-dot {
      filter: drop-shadow(0 0 8px currentColor);
    }

    /* Category Colors */
    .category-family { color: #e74c3c; }
    .category-ohs { color: #e67e22; }
    .category-disability { color: #f39c12; }
    .category-termination { color: #3498db; }
    .category-competence { color: #95a5a6; }

    /* Correspondence Colors - Different color for each person */
    .category-correspondence-danielle { color: #27ae60; }  /* Green for Danielle Schwartz */
    .category-correspondence-carol { color: #9b59b6; }     /* Purple for Carol Burke */
    .category-correspondence-michelle { color: #e91e63; }  /* Pink for Michelle Sherman */

    /* Tooltip for range bars */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 12px 16px;
      border-radius: 6px;
      font-size: 13px;
      pointer-events: none;
      z-index: 1000;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: none;
    }

    .tooltip-title {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 14px;
    }

    .tooltip-date {
      color: #aaa;
      font-size: 11px;
      margin-bottom: 8px;
    }

    .tooltip-desc {
      line-height: 1.4;
    }

    /* Side Panel (for full details on click) */
    .side-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -52%) scale(0.95);
      width: 820px;
      max-height: 95vh;
      background: var(--bg-card);
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      z-index: 2000;
      overflow-y: auto;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    }

    .side-panel.open {
      opacity: 1;
      transform: translate(-50%, -52%) scale(1);
      pointer-events: all;
    }

    .panel-header {
      position: sticky;
      top: 0;
      background: var(--bg-card);
      border-bottom: 2px solid var(--border-color);
      border-radius: 12px 12px 0 0;
      padding: 20px 20px 12px 20px;
      z-index: 10;
    }

    .panel-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .panel-date-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-date {
      color: #4a6fa5;
      font-size: 16px;
      font-weight: 700;
    }

    .panel-category {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      color: white;
    }

    .panel-content {
      padding: 10px 20px 20px 20px;
      opacity: 0;
      transition: opacity 0.3s ease-in-out 0.15s;
    }

    .side-panel.open .panel-content {
      opacity: 1;
    }

    .panel-section {
      margin-bottom: 14px;
    }

    .panel-section h3 {
      font-size: 16px;
      font-weight: 700;
      color: #2c3e50;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
      background: #f0f7ff;
      padding: 5px 12px;
      border-radius: 4px;
    }

    .panel-section p {
      line-height: 1.5;
      color: var(--text-primary);
    }

    .panel-section ul {
      list-style: none;
      padding: 0;
    }

    .panel-section li {
      padding: 1px 0;
      padding-left: 20px;
      position: relative;
      line-height: 1.4;
    }

    .panel-section li:before {
      content: "‚Ä¢";
      position: absolute;
      left: 6px;
      color: var(--text-secondary);
    }

    .legal-significance {
      background: #fff3cd;
      border-left: 4px solid #f39c12;
      padding: 16px;
      border-radius: 4px;
    }

    .legal-significance h3 {
      color: #856404 !important;
      background: transparent;
      padding: 0;
    }

    [data-theme="dark"] .legal-significance p,
    [data-theme="dark"] .legal-significance li {
      color: #2c2c2c;
    }

    /* Evidence Images */
    .evidence-images {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .evidence-image-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .evidence-image {
      width: 100%;
      height: auto;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .evidence-image.clickable {
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .evidence-image.clickable:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .evidence-caption {
      font-size: 13px;
      color: var(--text-secondary);
      font-style: italic;
      text-align: center;
      margin: 0;
    }

    /* Image Modal (centered on top of card) */
    .image-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 85vw;
      max-height: 95vh;
      background: var(--bg-card);
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      z-index: 2100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .image-modal.open {
      opacity: 1;
      pointer-events: all;
    }

    .image-modal-header {
      padding: 16px;
      background: var(--bg-card);
      border-bottom: 2px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .image-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--text-primary);
      padding: 4px 8px;
      line-height: 1;
    }

    .image-modal-close:hover {
      opacity: 0.7;
    }

    .image-modal-content {
      padding: 24px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      flex: 1;
    }

    .image-modal-content img {
      max-width: 100%;
      max-height: calc(95vh - 140px);
      width: auto;
      height: auto;
      border-radius: 4px;
      object-fit: contain;
    }

    .panel-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--panel-overlay);
      z-index: 1999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-in-out;
    }

    .panel-overlay.visible {
      opacity: 1;
      pointer-events: all;
    }

    /* Hide navigation elements when panel is open */
    .panel-overlay.visible ~ .container .nav-arrow,
    .panel-overlay.visible ~ .container .mini-map-container {
      display: none;
    }

    /* Date labels at ends */
    .date-label {
      font-size: 16px;
      font-weight: 600;
      color: var(--month-label-text);
    }

    /* Theme Toggle Button */
    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      box-shadow: var(--shadow-sm);
      transition: all 0.3s ease;
      z-index: 3000;
    }

    .theme-toggle:hover {
      transform: scale(1.1);
      box-shadow: var(--shadow-md);
    }

    .theme-toggle:active {
      transform: scale(0.95);
    }

    /* Timecard Viewer Button */
    .timecard-toggle {
      position: fixed;
      top: 80px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      box-shadow: var(--shadow-sm);
      transition: all 0.3s ease;
      z-index: 3000;
    }

    .timecard-toggle:hover {
      transform: scale(1.1);
      box-shadow: var(--shadow-md);
    }

    .timecard-toggle:active {
      transform: scale(0.95);
    }

    /* Timecard Viewer Modal */
    .timecard-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 4000;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .timecard-modal.open {
      display: flex;
    }

    .timecard-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: white;
      border: none;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s;
    }

    .timecard-close:hover {
      transform: scale(1.1);
    }

    .timecard-content {
      max-width: 95%;
      max-height: 90vh;
      overflow: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
      padding: 20px;
    }

    .timecard-image {
      max-width: calc(50% - 10px);
      height: auto;
      border: 2px solid white;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    /* Timecard System Diagram Modal */
    .diagram-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      z-index: 5000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .diagram-modal.open {
      display: flex;
    }

    .diagram-container {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 30px;
      max-width: 900px;
      max-height: 90vh;
      overflow: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      position: relative;
    }

    .diagram-close {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      color: var(--text-primary);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      z-index: 10;
    }

    .diagram-close:hover {
      transform: scale(1.1);
      background: #e74c3c;
      color: white;
      border-color: #e74c3c;
    }

    .diagram-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 10px;
      text-align: center;
    }

    .diagram-subtitle {
      font-size: 14px;
      color: var(--text-secondary);
      text-align: center;
      margin-bottom: 25px;
    }

    #diagram-canvas {
      display: block;
      margin: 0 auto;
      max-width: 100%;
    }

    /* Navigation Arrows */
    .nav-arrow {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      width: 21px;
      height: 70px;
      border-radius: 6px;
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      box-shadow: var(--shadow-md);
      transition: all 0.3s ease;
      z-index: 2500;
      opacity: 1;
    }

    .nav-arrow:hover {
      transform: translateY(-50%) scale(1.05);
      box-shadow: var(--shadow-lg);
      background: var(--hover-bg);
    }

    .nav-arrow:active {
      transform: translateY(-50%) scale(0.98);
    }

    .nav-arrow.disabled {
      opacity: 0.3;
      cursor: not-allowed;
      pointer-events: none;
    }

    .nav-arrow-left {
      left: 8px;
    }

    .nav-arrow-right {
      right: 8px;
    }

    /* Mini-map */
    .mini-map-container {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 900px;
      height: 40px;
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 5px 15px;
      box-shadow: var(--shadow-md);
      z-index: 2500;
    }

    .mini-map-timeline {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .mini-map-line {
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--timeline-line);
      transform: translateY(-50%);
    }

    .mini-map-event {
      position: absolute;
      top: 50%;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      cursor: pointer;
      transition: all 0.2s;
    }

    .mini-map-event:hover {
      transform: translate(-50%, -50%) scale(1.5);
    }

    .mini-map-viewport {
      position: absolute;
      top: 0;
      height: 100%;
      background: rgba(52, 152, 219, 0.2);
      border: 2px solid #3498db;
      border-radius: 4px;
      cursor: grab;
      transition: left 0.5s ease, width 0.5s ease;
    }

    .mini-map-viewport:active {
      cursor: grabbing;
    }

  </style>
</head>
<body>
  <!-- Theme Toggle Button -->
  <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
    <span id="theme-icon">‚òÄÔ∏è</span>
  </button>

  <!-- Timecard Viewer Button -->
  <button class="timecard-toggle" id="timecard-toggle" aria-label="View timecards">
    <span>üìÖ</span>
  </button>

  <!-- Timecard Viewer Modal -->
  <div class="timecard-modal" id="timecard-modal">
    <button class="timecard-close" id="timecard-close" aria-label="Close timecards">√ó</button>
    <div class="timecard-content" id="timecard-content">
      <!-- Timecard images will be dynamically inserted here -->
    </div>
  </div>

  <!-- Timecard System Diagram Modal -->
  <div class="diagram-modal" id="diagram-modal">
    <div class="diagram-container">
      <button class="diagram-close" id="diagram-close" aria-label="Close diagram">√ó</button>
      <h2 class="diagram-title">How The Timecard System Actually Works</h2>
      <p class="diagram-subtitle">(And Why It Was Designed to Fail)</p>
      <canvas id="diagram-canvas"></canvas>
    </div>
  </div>

  <!-- Navigation Arrows -->
  <button class="nav-arrow nav-arrow-left" id="nav-arrow-left" aria-label="Navigate left">
    ‚óÄ
  </button>
  <button class="nav-arrow nav-arrow-right" id="nav-arrow-right" aria-label="Navigate right">
    ‚ñ∂
  </button>

  <!-- Mini-map -->
  <div class="mini-map-container" id="mini-map-container">
    <div class="mini-map-timeline" id="mini-map-timeline">
      <div class="mini-map-line"></div>
      <div class="mini-map-viewport" id="mini-map-viewport"></div>
    </div>
  </div>

  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>Wrongful Dismissal Case Timeline</h1>
      <div class="subtitle">Jan 2024 - Oct 2025 ‚Ä¢ <span id="event-count">35 events</span></div>

      <div class="controls">
        <button class="view-btn active" data-view="overview">Overview</button>
        <button class="view-btn" data-view="family">Family Status</button>
        <button class="view-btn" data-view="disability">Disability</button>
        <button class="view-btn" data-view="just-cause-failure">Just Cause Failure</button>
        <button class="view-btn" data-view="bad-faith-conduct">Bad Faith Conduct</button>
        <button class="view-btn" data-view="post-termination-misconduct">Post-Termination Misconduct</button>
        <button class="view-btn" data-view="ohs">OHS Retaliation</button>
      </div>

      <!-- Lateness Sub-Filters (shown when Human Rights filter is active) -->
      <div class="lateness-subfilters" id="lateness-subfilters">
        <span class="lateness-label">Lateness:</span>
        <button class="lateness-btn" data-person="employee" title="Employee Lateness">Employee</button>
        <button class="lateness-btn" data-person="boss-coworker" title="Boss/Coworker Lateness">Boss/Coworker</button>
      </div>
    </div>

    <!-- Timeline -->
    <div class="timeline-wrapper" id="timeline"></div>
  </div>

  <!-- Tooltip -->
  <div class="tooltip" id="tooltip">
    <div class="tooltip-title"></div>
    <div class="tooltip-date"></div>
    <div class="tooltip-desc"></div>
  </div>

  <!-- Side Panel Overlay -->
  <div class="panel-overlay" id="panel-overlay"></div>

  <!-- Side Panel -->
  <div class="side-panel" id="side-panel">
    <div class="panel-header">
      <div class="panel-title" id="panel-title"></div>
      <div class="panel-date-row">
        <div class="panel-date" id="panel-date"></div>
        <div class="panel-category" id="panel-category"></div>
      </div>
    </div>
    <div class="panel-content" id="panel-content"></div>
  </div>

  <!-- Image Modal (for enlarged view) -->
  <div class="image-modal" id="image-modal">
    <div class="image-modal-header">
      <span id="image-modal-title">Evidence Image</span>
      <button class="image-modal-close" id="image-modal-close">√ó</button>
    </div>
    <div class="image-modal-content" id="image-modal-content"></div>
  </div>

  <!-- Load Event Data with cache-busting timestamp -->
  <script>
    // Dynamically load data.js with timestamp to bust GitHub Pages CDN cache
    var dataLoaded = false;
    var domReady = false;

    function tryInit() {
      if (dataLoaded && domReady && typeof init === 'function') {
        init();
      }
    }

    (function() {
      var script = document.createElement('script');
      script.src = 'js/data.js?t=' + Date.now();
      script.onload = function() {
        console.log('üì¶ data.js loaded with cache bust');
        dataLoaded = true;
        tryInit();
      };
      document.head.appendChild(script);
    })();
  </script>

  <!-- Timeline Implementation -->
  <script>
    // Theme Management
    function initTheme() {
      // Check localStorage first, then system preference
      const savedTheme = localStorage.getItem('theme');
      const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = savedTheme || (systemPrefersDark ? 'dark' : 'light');

      applyTheme(theme);
      updateThemeIcon(theme);

      // Listen for theme toggle clicks
      document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

      // Listen for system theme changes (if no saved preference)
      if (!savedTheme) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
          const newTheme = e.matches ? 'dark' : 'light';
          applyTheme(newTheme);
          updateThemeIcon(newTheme);
        });
      }
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';

      applyTheme(newTheme);
      updateThemeIcon(newTheme);
      localStorage.setItem('theme', newTheme);

      // Notify diagram modal to redraw if open
      window.dispatchEvent(new Event('themeChanged'));
    }

    function applyTheme(theme) {
      if (theme === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
      } else {
        document.documentElement.removeAttribute('data-theme');
      }
    }

    function updateThemeIcon(theme) {
      const icon = document.getElementById('theme-icon');
      icon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
    }

    // Initialize theme on page load
    initTheme();

    // Category colors
    const categoryColors = {
      family: '#e74c3c',
      ohs: '#e67e22',
      disability: '#f39c12',
      termination: '#3498db',
      competence: '#95a5a6',
      'correspondence-danielle': '#27ae60',
      'correspondence-carol': '#9b59b6',
      'correspondence-michelle': '#e91e63'
    };

    // Helper function to get effective color (respects lateness filter overrides)
    function getEffectiveColor(event) {
      // Check if employee lateness subfilter is active
      if (activeLatenessFilters.has('employee')) {
        // Check tags OR multiday event ID list
        if ((event.tags && event.tags.includes('lateness-employee')) || latenessEmployeeRangeEvents.includes(event.id)) {
          return '#4A90E2';  // Blue for employee lateness
        }
      }

      // Check if boss/coworker lateness subfilter is active
      if (activeLatenessFilters.has('boss-coworker')) {
        // Check tags OR multiday event ID list
        if ((event.tags && (event.tags.includes('lateness-boss') || event.tags.includes('lateness-coworker'))) || latenessBossRangeEvents.includes(event.id)) {
          return '#FF8C42';  // Orange for boss/coworker lateness
        }
      }

      // No override - return original category color
      return categoryColors[event.category];
    }

    const categoryLabels = {
      family: 'Family Status',
      ohs: 'OHS Retaliation',
      disability: 'Disability',
      termination: 'Termination Evidence',
      competence: 'Technical Competence',
      'correspondence-danielle': 'Danielle Schwartz (Payroll)',
      'correspondence-carol': 'Carol Burke (Lawyer)',
      'correspondence-michelle': 'Michelle Sherman (HR)'
    };

    // Range bar colors (cycle through these for visual variety)
    const rangeBarColors = [
      '#5DADE2',  // Sky Blue
      '#48C9B0',  // Teal/Aqua
      '#E67E22',  // Orange
      '#9B59B6'   // Purple
    ];

    let currentView = 'overview';
    let activeLatenessFilters = new Set(); // Track which lateness person filters are active

    // Multiday events to include in lateness subfilters (by event ID)
    const latenessEmployeeRangeEvents = [
      76,  // 9-MONTH ACCOMMODATION: "Being Late is Okay"
      21,  // OVERTIME MARATHON: 18 Consecutive Days
      80,  // PARENTAL LEAVE PERIOD: 5 Weeks
      75   // TIMECARD REMINDER PATTERN: Boss Reminds 4 Times in 52 Days
    ];
    const latenessBossRangeEvents = [
      67   // DIFFERENTIAL TREATMENT: Boss Lateness Pattern (6 Instances)
    ];

    // Multiday events to include in specialized filter views (by event ID)
    // Family Status: 76, 80 via tags + add 21, 67
    const familyStatusRangeEvents = [
      21,  // OVERTIME MARATHON: Eliminated family time for 18 days
      67   // DIFFERENTIAL TREATMENT: Boss lateness pattern (comparator)
    ];
    // Disability: All from Family Status + 75 via tag
    const disabilityRangeEvents = [
      76,  // 9-MONTH ACCOMMODATION: Boss knew about disabilities
      21,  // OVERTIME MARATHON: Exhaustion exacerbates disabilities
      80,  // PARENTAL LEAVE: Context for disability-related termination
      67   // DIFFERENTIAL TREATMENT: Boss has same conditions
    ];
    // Just Cause Failure: ALL multiday events
    const justCauseRangeEvents = [
      3,   // HYDRAULIC: Employee proven right (undermines incompetence claim)
      76,  // 9-MONTH ACCOMMODATION: FATAL - can't claim just cause for accepted conduct
      21,  // OVERTIME MARATHON: Employee worked voluntarily (undermines unreliable)
      80,  // PARENTAL LEAVE: Protected leave (can't use for just cause)
      67,  // DIFFERENTIAL TREATMENT: Same conduct, different treatment
      75   // TIMECARD PATTERN: Systemic issue, not employee fault
    ];
    // Bad Faith Conduct: ALL multiday events
    const badFaithRangeEvents = [
      3,   // HYDRAULIC: Origin of retaliation pattern
      76,  // 9-MONTH ACCOMMODATION: Withdrawal was punishment
      21,  // OVERTIME MARATHON: Created exhaustion then disciplined for it
      80,  // PARENTAL LEAVE: Textbook retaliation timing
      67,  // DIFFERENTIAL TREATMENT: Proves pretextual targeting
      75   // TIMECARD PATTERN: Boss admits system broken
    ];

    // Viewport state for virtual scrolling (event-based)
    let currentViewportIndex = 0; // Current page index (0, 1, 2, ...)
    let eventsPerViewport = 10; // Dynamically calculated
    let viewportStartDate = null;
    let viewportEndDate = null;
    let allFilteredEvents = []; // Cache of all filtered events
    let singleDayEvents = []; // Single-day events (used for pagination)
    let multiDayEvents = []; // Multi-day events (appear on all overlapping pages)
    let fullTimelineStart = null;
    let fullTimelineEnd = null;
    let miniMapDragInitialized = false; // Prevent duplicate drag listeners

    // Calculate optimal events per viewport (target 10-12 events)
    function calculateEventsPerViewport(totalEvents) {
      if (totalEvents <= 12) return totalEvents; // Show all if 12 or fewer

      // Try divisors to get close to 10-12 per screen
      for (let divisor = 2; divisor <= totalEvents; divisor++) {
        const eventsPerScreen = Math.ceil(totalEvents / divisor);
        if (eventsPerScreen >= 10 && eventsPerScreen <= 12) {
          return eventsPerScreen;
        }
      }

      // Fallback: aim for ~11 per screen
      return Math.max(10, Math.ceil(totalEvents / Math.ceil(totalEvents / 11)));
    }

    // Layer configuration
    const CARD_WIDTH = 280;
    const MIN_GAP = 5; // Minimum spacing between cards (tight packing allowed)
    const MAX_OFFSET = 300; // Maximum horizontal shift allowed (increased for flexibility)
    const LAYERS = {
      above3: 460,  // Farthest above (maintains 180px gap from Tier 2)
      above2: 280,  // Far above (maintains 180px gap from Tier 1)
      above1: 100,  // Near above (60px closer to timeline)
      below1: 100,  // Near below (60px closer to timeline)
      below2: 280,  // Far below (maintains 180px gap from Tier 1)
      below3: 460   // Farthest below (maintains 180px gap from Tier 2)
    };

    // Date parser (global scope for use across functions)
    const parseDate = d3.timeParse('%Y-%m-%d');

    // Initialize
    function init() {
      // DEBUG: Check if data loaded
      console.log('üîç DEBUG: Initializing timeline...');
      console.log('üîç DEBUG: timelineEvents exists?', typeof timelineEvents !== 'undefined');
      console.log('üîç DEBUG: Total events loaded:', timelineEvents ? timelineEvents.length : 0);

      // Parse all dates once at startup (performance optimization)
      timelineEvents.forEach(e => {
        // Remove question marks from uncertain dates before parsing
        const cleanTimestamp = e.timestamp.replace('?', '');
        e.parsedDate = parseDate(cleanTimestamp);
        if (e.endDate) {
          const cleanEndDate = e.endDate.replace('?', '');
          e.parsedEndDate = parseDate(cleanEndDate);
        }
      });

      setupViewButtons();
      setupLatenessButtons();
      setupNavigationButtons();
      setupTimecardViewer();
      setupDiagramModal();

      // Initialize with filtered events
      console.log('üîç DEBUG: Current view:', currentView);
      allFilteredEvents = getFilteredEvents();
      console.log('üîç DEBUG: Filtered events:', allFilteredEvents.length);
      initializeViewport(allFilteredEvents);
      renderTimeline(allFilteredEvents);
      updateEventCount();
      setupPanelListeners();
      renderMiniMap();
    }

    // Initialize viewport based on filtered events (event-based pagination)
    function initializeViewport(events) {
      if (events.length === 0) {
        viewportStartDate = null;
        viewportEndDate = null;
        fullTimelineStart = null;
        fullTimelineEnd = null;
        currentViewportIndex = 0;
        eventsPerViewport = 10;
        singleDayEvents = [];
        multiDayEvents = [];
        return;
      }

      // Separate single-day and multi-day events
      singleDayEvents = events.filter(e => !e.parsedEndDate || e.parsedEndDate.getTime() === e.parsedDate.getTime());
      multiDayEvents = events.filter(e => e.parsedEndDate && e.parsedEndDate.getTime() !== e.parsedDate.getTime());

      // OHS SPECIAL CASE: Include event ID 3 (Hydraulic Dispute) in pagination
      if (currentView === 'ohs') {
        const event3 = multiDayEvents.find(e => e.id === 3);
        if (event3) {
          singleDayEvents.push(event3);
          multiDayEvents = multiDayEvents.filter(e => e.id !== 3);
        }
      }

      console.log('üîç DEBUG: Separated events - Single-day:', singleDayEvents.length, 'Multi-day:', multiDayEvents.length);

      // Calculate full timeline range (dates already parsed in init())
      const allDates = [];
      events.forEach(e => {
        allDates.push(e.parsedDate);
        if (e.parsedEndDate) allDates.push(e.parsedEndDate);
      });
      fullTimelineStart = d3.min(allDates);
      fullTimelineEnd = d3.max(allDates);

      // Calculate optimal events per viewport based on SINGLE-DAY events only
      eventsPerViewport = calculateEventsPerViewport(singleDayEvents.length);

      // Override for Family Status view: 2-page layout
      // Page 1: First 7 events (through July 6)
      // Page 2: ALL remaining events (Aug 4 through termination)
      if (currentView === 'family') {
        eventsPerViewport = 7; // First 7 events on page 1, rest on page 2
      }

      // Override for Disability view: reduce page 1 to prevent overlap
      // Push 2 events from page 1 to page 2 for better card spacing
      if (currentView === 'disability') {
        eventsPerViewport = 8; // Fewer events on page 1 to prevent overlap
      }

      // Override for Just Cause Failure view: include Aug 5 and Aug 9 on page 1
      if (currentView === 'just-cause-failure') {
        eventsPerViewport = 14; // Ensure Aug 5 and Aug 9 appear on first page
      }

      // Reset to first page
      currentViewportIndex = 0;

      // Update viewport dates based on first page of SINGLE-DAY events
      updateViewportDates(events);
      updateNavigationButtons(events);
    }

    // Update viewport date range based on current page index
    function updateViewportDates(events) {
      if (singleDayEvents.length === 0) return;

      // Sort SINGLE-DAY events by date (pagination based on these only)
      const sortedSingleDay = [...singleDayEvents].sort((a, b) => a.parsedDate - b.parsedDate);

      // Get single-day events for current viewport page
      const startIdx = currentViewportIndex * eventsPerViewport;
      let endIdx = Math.min(startIdx + eventsPerViewport, sortedSingleDay.length);

      // FAMILY STATUS SPECIAL CASE: Force only 2 pages (page 2 shows ALL remaining events)
      if (currentView === 'family' && currentViewportIndex === 1) {
        endIdx = sortedSingleDay.length; // Show all remaining events on page 2
      }

      const viewportSingleDayEvents = sortedSingleDay.slice(startIdx, endIdx);

      if (viewportSingleDayEvents.length === 0) return;

      // Calculate date range from SINGLE-DAY events only
      const viewportDates = [];
      viewportSingleDayEvents.forEach(e => {
        viewportDates.push(e.parsedDate);
        // For single-day events, only use start date
        if (e.parsedEndDate) viewportDates.push(e.parsedEndDate);
      });

      viewportStartDate = d3.min(viewportDates);
      viewportEndDate = d3.max(viewportDates);

      // Add small padding (1 day on each side) for visual breathing room
      viewportStartDate = d3.timeDay.offset(viewportStartDate, -1);
      viewportEndDate = d3.timeDay.offset(viewportEndDate, 1);

      console.log('üîç DEBUG: Viewport date range:', viewportStartDate, 'to', viewportEndDate);
    }

    // Get events within current viewport
    function getViewportEvents(events) {
      if (!viewportStartDate || !viewportEndDate) {
        return events;
      }

      return events.filter(e => {
        // Use pre-parsed dates (already parsed in init())
        const eventDate = e.parsedDate;
        const eventEndDate = e.parsedEndDate || eventDate;

        // Include event if it overlaps with viewport
        return (eventDate <= viewportEndDate && eventEndDate >= viewportStartDate);
      });
    }

    // Move viewport left (earlier dates / previous page)
    function moveViewportLeft() {
      if (currentViewportIndex <= 0) return;

      currentViewportIndex--;
      updateViewportDates(allFilteredEvents);
      updateNavigationButtons(allFilteredEvents);
      renderTimeline(allFilteredEvents);
      renderMiniMap();
    }

    // Move viewport right (later dates / next page)
    function moveViewportRight() {
      let totalPages = Math.ceil(singleDayEvents.length / eventsPerViewport);

      // FAMILY STATUS SPECIAL CASE: Force only 2 pages
      if (currentView === 'family' && singleDayEvents.length > eventsPerViewport) {
        totalPages = 2; // Always exactly 2 pages for family status
      }

      if (currentViewportIndex >= totalPages - 1) return;

      currentViewportIndex++;
      updateViewportDates(allFilteredEvents);
      updateNavigationButtons(allFilteredEvents);
      renderTimeline(allFilteredEvents);
      renderMiniMap();
    }

    // Update navigation button states
    function updateNavigationButtons(events) {
      const leftBtn = document.getElementById('nav-arrow-left');
      const rightBtn = document.getElementById('nav-arrow-right');

      if (!events || events.length === 0) {
        leftBtn.classList.add('disabled');
        rightBtn.classList.add('disabled');
        return;
      }

      // Calculate total pages based on SINGLE-DAY events only
      let totalPages = Math.ceil(singleDayEvents.length / eventsPerViewport);

      // FAMILY STATUS SPECIAL CASE: Force only 2 pages
      if (currentView === 'family' && singleDayEvents.length > eventsPerViewport) {
        totalPages = 2; // Always exactly 2 pages for family status
      }

      // Disable left if on first page
      if (currentViewportIndex <= 0) {
        leftBtn.classList.add('disabled');
      } else {
        leftBtn.classList.remove('disabled');
      }

      // Disable right if on last page
      if (currentViewportIndex >= totalPages - 1) {
        rightBtn.classList.add('disabled');
      } else {
        rightBtn.classList.remove('disabled');
      }
    }

    // Setup navigation button listeners
    function setupNavigationButtons() {
      document.getElementById('nav-arrow-left').addEventListener('click', moveViewportLeft);
      document.getElementById('nav-arrow-right').addEventListener('click', moveViewportRight);
    }

    // Get filtered events based on view (tag-based)
    function getFilteredEvents() {
      console.log('üîç DEBUG: getFilteredEvents() called, currentView =', currentView);
      console.log('üîç DEBUG: activeLatenessFilters =', Array.from(activeLatenessFilters));
      let events = [...timelineEvents];
      console.log('üîç DEBUG: Starting with', events.length, 'total events');

      // Apply main tag filter - with special handling for family/disability with lateness filters
      if (currentView === 'critical') {
        events = events.filter(e => e.tags && e.tags.includes('critical'));
        console.log('üîç DEBUG: After critical filter:', events.length, 'events');
      } else if (currentView === 'overview') {
        // Overview filter: Comprehensive convergence timeline for lawyer consultation
        // Covers all 3 tracks: Protected Grounds, Protected Activities/Reprisals, Pretextual Discipline
        const overviewEventIds = [
          // TRACK 1: Protected Grounds & Accommodation (Foundation)
          71,  // First Interview - Family Priority Disclosed
          1,   // Hired as Electrical Technician
          2,   // ADHD Disclosed (Pre-Employment)
          6,   // Baby Born
          76,  // Accommodation Agreement (flexible schedule)
          9,   // Sleep Apnea Diagnosed (Feb 2025)

          // TRACK 2: Protected Activities & Reprisals (Triggers)
          3,   // Hydraulic Troubleshooting Victory (OHS advocacy origin)
          5,   // Confined Space Safety Meeting - Sent Home
          84,  // Feb 20 - Hydraulic Fittings VP Dispute (triggered Feb 21 write-up)
          8,   // Hydraulic Lines Write-Up - Safety Research Punished
          21,  // July 14-31 - OVERTIME MARATHON (18 consecutive days)
          22,  // July 21 - Accommodation Revoked (SG #1)
          28,  // Aug 28 - Sick Baby Denial
          73,  // Michelle Sherman "Everyone has children" (SG #2)
          74,  // Aug 4 - Personal Day Denied (Boss Lied)
          80,  // Sept 4-Oct 9 - PARENTAL LEAVE PERIOD (5 weeks)
          36,  // Sept 7 - "Urgent" Email (SG #3)

          // TRACK 3: Pretextual Discipline & Bad Faith (Execution)
          4,   // Write-Up #1A (Timecards - Feb 21, 10:10 AM)
          75,  // Jul 4 - Aug 25 - TIMECARD REMINDER PATTERN (systemic issue)
          26,  // Headphones incident (leads to Write-Up #1)
          64,  // Write-Up #1B Document (OHS Retaliation - Feb 21, 4:46 PM)
          14,  // June 13 - Approved Absence (Boss: "Yes you're good")
          79,  // Write-Up #2 - Falsifies June 13 as "not communicated" (SG)
          65,  // Write-Up #4 - Disciplinary Record on Return from Leave (SG #4)
          33,  // Oct 20 - Accommodation Request Denied
          34,  // Oct 21 - Employee Backs Down
          66,  // Timecard Unlock Catch-22 (SG #7)
          35,  // Oct 22 - Termination (SG #5)

          // SMOKING GUNS & COMPARATORS (Differential Treatment)
          67,  // Boss Lateness Pattern (range) - covers all 6 individual instances
          59,  // Jessica Differential Treatment (sick note)

          // POST-TERMINATION BAD FAITH
          52,  // Nov 4 - CORRECTED DOCUMENTS "Dear Rollins:" Error (SG #6)
          61   // ROE Released (14-day delay)
        ];
        events = events.filter(e => overviewEventIds.includes(e.id));
        console.log('üîç DEBUG: After overview filter:', events.length, 'events');
      } else if (currentView === 'family') {
        // Family Status view - tag-based filtering with routine lateness exclusion
        if (activeLatenessFilters.size === 0) {
          // No lateness filters: show family events EXCLUDING routine lateness notifications
          // Exclude Jan 10 interview (id 71) to widen timeline
          events = events.filter(e =>
            e.id !== 71 && (
              (e.tags && e.tags.includes('family') &&
               // Exclude routine lateness (but keep smoking-guns like Oct 10 Return)
               !(e.tags.includes('lateness-employee') &&
                 !e.tags.includes('smoking-gun') &&
                 !e.tags.includes('critical'))
              ) ||
              familyStatusRangeEvents.includes(e.id)
            )
          );
        } else {
          // Lateness filters active: show ONLY matching lateness events
          events = events.filter(e => {
            if (activeLatenessFilters.has('employee')) {
              if ((e.tags && e.tags.includes('lateness-employee')) || latenessEmployeeRangeEvents.includes(e.id)) return true;
            }
            if (activeLatenessFilters.has('boss-coworker')) {
              if ((e.tags && (e.tags.includes('lateness-boss') || e.tags.includes('lateness-coworker'))) || latenessBossRangeEvents.includes(e.id)) return true;
            }
            return false;
          });
        }
        console.log('üîç DEBUG: After family filter:', events.length, 'events');
      } else if (currentView === 'disability') {
        // Disability view: show disability events + ALL lateness (employee + boss/coworker as comparators)
        // Boss has same disabilities (ADHD + sleep apnea) - his lateness without discipline proves differential treatment
        events = events.filter(e =>
          (e.tags && e.tags.includes('disability')) ||
          (e.tags && e.tags.includes('lateness-employee')) ||
          (e.tags && e.tags.includes('lateness-boss')) ||
          (e.tags && e.tags.includes('lateness-coworker')) ||
          disabilityRangeEvents.includes(e.id) ||
          latenessEmployeeRangeEvents.includes(e.id) ||
          latenessBossRangeEvents.includes(e.id)
        );
        console.log('üîç DEBUG: After disability filter:', events.length, 'events');
      } else if (currentView === 'just-cause-failure') {
        if (activeLatenessFilters.size === 0) {
          // No lateness filters: show full just cause view
          events = events.filter(e =>
            (e.tags && e.tags.includes('just-cause-failure')) ||
            justCauseRangeEvents.includes(e.id)
          );
        } else {
          // Lateness filters active: show ONLY matching lateness events
          events = events.filter(e => {
            if (activeLatenessFilters.has('employee')) {
              if ((e.tags && e.tags.includes('lateness-employee')) || latenessEmployeeRangeEvents.includes(e.id)) return true;
            }
            if (activeLatenessFilters.has('boss-coworker')) {
              if ((e.tags && (e.tags.includes('lateness-boss') || e.tags.includes('lateness-coworker'))) || latenessBossRangeEvents.includes(e.id)) return true;
            }
            return false;
          });
        }
        console.log('üîç DEBUG: After just-cause-failure filter:', events.length, 'events');
      } else if (currentView === 'bad-faith-conduct') {
        // Include events with tag OR multiday events from ID list
        events = events.filter(e =>
          (e.tags && e.tags.includes('bad-faith-conduct')) ||
          badFaithRangeEvents.includes(e.id)
        );
        console.log('üîç DEBUG: After bad-faith-conduct filter:', events.length, 'events');
      } else if (currentView === 'post-termination-misconduct') {
        events = events.filter(e => e.tags && e.tags.includes('post-termination-misconduct'));
        console.log('üîç DEBUG: After post-termination-misconduct filter:', events.length, 'events');
      } else if (currentView === 'ohs') {
        events = events.filter(e => e.tags && e.tags.includes('ohs'));
        console.log('üîç DEBUG: After ohs filter:', events.length, 'events');
      }
      // 'all' view shows everything - no filter applied

      console.log('üîç DEBUG: Returning', events.length, 'events');
      return events;
    }

    // Setup view buttons
    function setupViewButtons() {
      document.querySelectorAll('.view-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentView = btn.dataset.view;

          // Show/hide lateness subfilters for views with lateness evidence
          const latenessSubfilters = document.getElementById('lateness-subfilters');
          const viewsWithLatenessSubfilters = [
            'family',                        // Family status - lateness excluded by default, sub-filter to show
            'just-cause-failure'             // Differential treatment (boss vs employee)
            // Note: 'disability' removed - now shows ALL lateness by default (employee + boss as comparators)
          ];
          if (viewsWithLatenessSubfilters.includes(currentView)) {
            latenessSubfilters.classList.add('visible');
            // ALWAYS reset lateness filters when entering view with subfilters
            activeLatenessFilters.clear();
            document.querySelectorAll('.lateness-btn').forEach(btn => btn.classList.remove('active'));
          } else {
            latenessSubfilters.classList.remove('visible');
            // Reset lateness filters when leaving view with subfilters
            activeLatenessFilters.clear();
            document.querySelectorAll('.lateness-btn').forEach(btn => btn.classList.remove('active'));
          }

          // Get filtered events and initialize viewport
          allFilteredEvents = getFilteredEvents();
          initializeViewport(allFilteredEvents);
          renderTimeline(allFilteredEvents);
          updateEventCount();
          renderMiniMap();
        });
      });
    }

    // Setup lateness person filter buttons
    function setupLatenessButtons() {
      document.querySelectorAll('.lateness-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const personType = btn.dataset.person;

          // Toggle the filter
          if (activeLatenessFilters.has(personType)) {
            activeLatenessFilters.delete(personType);
            btn.classList.remove('active');
          } else {
            activeLatenessFilters.add(personType);
            btn.classList.add('active');
          }

          // Get filtered events and initialize viewport
          allFilteredEvents = getFilteredEvents();
          initializeViewport(allFilteredEvents);
          renderTimeline(allFilteredEvents);
          updateEventCount();
          renderMiniMap();
        });
      });
    }

    // Update event count
    function updateEventCount() {
      const count = allFilteredEvents.length;
      document.getElementById('event-count').textContent =
        `${count} event${count !== 1 ? 's' : ''}`;
    }

    // Tooltip functions
    function showTooltip(event, data, mouseEvent) {
      const tooltip = d3.select('#tooltip');

      tooltip.select('.tooltip-title').text(data.text);

      const dateStr = `${d3.timeFormat('%B %d, %Y')(data.parsedDate)} - ${d3.timeFormat('%B %d, %Y')(data.parsedEndDate)}`;
      tooltip.select('.tooltip-date').text(dateStr);

      const desc = data.description.length > 150
        ? data.description.substring(0, 150) + '...'
        : data.description;
      tooltip.select('.tooltip-desc').text(desc);

      tooltip.style('display', 'block');
      moveTooltip(mouseEvent);
    }

    function moveTooltip(event) {
      const tooltip = d3.select('#tooltip');
      tooltip
        .style('left', (event.pageX + 15) + 'px')
        .style('top', (event.pageY - 15) + 'px');
    }

    function hideTooltip() {
      d3.select('#tooltip').style('display', 'none');
    }

    // Render timeline
    function renderTimeline(events) {
      console.log('üîç DEBUG: renderTimeline() called with', events.length, 'events');
      console.log('üîç DEBUG: currentViewportIndex =', currentViewportIndex, 'eventsPerViewport =', eventsPerViewport);
      const container = d3.select('#timeline');
      container.html(''); // Clear

      // STEP 1: Get SINGLE-DAY events for current page
      const sortedSingleDay = [...singleDayEvents].sort((a, b) => a.parsedDate - b.parsedDate);
      const startIdx = currentViewportIndex * eventsPerViewport;
      const endIdx = Math.min(startIdx + eventsPerViewport, sortedSingleDay.length);
      const pageSingleDayEvents = sortedSingleDay.slice(startIdx, endIdx);

      console.log('üîç DEBUG: Single-day events for page:', pageSingleDayEvents.length);

      // STEP 2: Get MULTI-DAY events that overlap with viewport date range
      const overlappingMultiDay = multiDayEvents.filter(e => {
        const eventStart = e.parsedDate;
        const eventEnd = e.parsedEndDate;
        // Include if event overlaps with viewport
        return (eventStart <= viewportEndDate && eventEnd >= viewportStartDate);
      });

      console.log('üîç DEBUG: Overlapping multi-day events:', overlappingMultiDay.length);

      // STEP 3: Combine single-day + overlapping multi-day events
      const viewportEvents = [...pageSingleDayEvents, ...overlappingMultiDay];
      console.log('üîç DEBUG: Total viewport events:', viewportEvents.length, '(', pageSingleDayEvents.length, 'single-day +', overlappingMultiDay.length, 'multi-day)');

      if (viewportEvents.length === 0) {
        console.log('‚ö†Ô∏è DEBUG: No events in viewport! Showing empty message.');
        container.append('div')
          .style('text-align', 'center')
          .style('color', '#999')
          .style('padding', '60px')
          .text('No events in this viewport section');
        return;
      }

      // Sort events by date (for initial processing)
      viewportEvents.sort((a, b) => a.parsedDate - b.parsedDate);

      // Assign alternating preference based on chronological order
      // This ensures visual left-to-right alternating pattern
      let chronologicalIndex = 0;
      viewportEvents.forEach(e => {
        if (e.type !== 'range') {
          e.preferAbove = chronologicalIndex % 2 === 0;
          chronologicalIndex++;
        }
      });

      // Use viewport date range for timeline display
      let minDate, maxDate;
      if (!viewportStartDate || !viewportEndDate) {
        // Fallback to calculating from events if viewport not initialized
        const allDates = [];
        viewportEvents.forEach(e => {
          allDates.push(e.parsedDate);
          if (e.parsedEndDate) allDates.push(e.parsedEndDate);
        });
        minDate = d3.min(allDates);
        maxDate = d3.max(allDates);
      } else {
        // Use viewport boundaries (already includes appropriate range)
        minDate = viewportStartDate;
        maxDate = viewportEndDate;
      }

      // Dimensions - use 97% of container width with optimized margins
      // Use taller height for "all" view to accommodate Tier 3
      const containerWidth = container.node().clientWidth;
      const width = containerWidth * 0.97;
      const height = currentView === 'all' ? 1400 : 800;
      const minMargin = CARD_WIDTH / 2 + 5; // 140 + 5 = 145px (5px clearance from edges)
      const margin = {
        top: 80,
        right: Math.max(containerWidth * 0.015, minMargin),
        left: Math.max(containerWidth * 0.015, minMargin),
        bottom: 80
      };
      const timelineY = height / 2;

      // Create SVG
      const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);

      // Create scale with dynamic domain
      const xScale = d3.scaleTime()
        .domain([minDate, maxDate])
        .range([margin.left, width - margin.right]);

      // Calculate spatial center of timeline
      const timelineCenter = (margin.left + (width - margin.right)) / 2;

      // Calculate X position for each event
      viewportEvents.forEach(e => {
        e.x = xScale(e.parsedDate);
        // Validate that x position is a valid number
        if (!e.x || isNaN(e.x)) {
          console.error('‚ö†Ô∏è Invalid X position for event:', e.timestamp, 'parsedDate:', e.parsedDate);
          // Use a default position at the start of timeline if date parsing failed
          e.x = margin.left + 100;
        }
      });

      // Keep chronological order for processing (already sorted at line 1822)
      // This ensures events are processed left-to-right, preserving chronological order
      // Earlier events placed first will constrain later events (no later event can be left of earlier)

      // Draw timeline line
      svg.append('line')
        .attr('class', 'timeline-line')
        .attr('x1', margin.left)
        .attr('y1', timelineY)
        .attr('x2', width - margin.right)
        .attr('y2', timelineY);

      // Generate dynamic month markers based on date range
      const monthMarkers = [];
      const rangeMonths = d3.timeMonth.count(minDate, maxDate);

      if (currentView === 'all') {
        // For full view, show start of each year + last event month
        monthMarkers.push({ date: parseDate('2024-01-01'), label: "Jan '24" });
        monthMarkers.push({ date: parseDate('2025-01-01'), label: "Jan '25" });
        monthMarkers.push({ date: parseDate('2025-10-01'), label: "Oct '25" });
      } else if (rangeMonths <= 6) {
        // For short ranges (6 months or less), show every month
        let currentMonth = d3.timeMonth.floor(minDate);
        while (currentMonth <= maxDate) {
          monthMarkers.push({
            date: currentMonth,
            label: d3.timeFormat("%b '%y")(currentMonth)
          });
          currentMonth = d3.timeMonth.offset(currentMonth, 1);
        }
      } else {
        // For medium ranges (6-18 months), show every 2-3 months
        let currentMonth = d3.timeMonth.floor(minDate);
        const interval = rangeMonths > 12 ? 3 : 2;
        while (currentMonth <= maxDate) {
          monthMarkers.push({
            date: currentMonth,
            label: d3.timeFormat("%b '%y")(currentMonth)
          });
          currentMonth = d3.timeMonth.offset(currentMonth, interval);
        }
      }

      // Create cards container
      const cardsContainer = container.append('div')
        .attr('class', 'cards-container');

      // Track occupied layers and offset counts for staggering L-connectors
      const occupiedLayers = {
        above1: [],
        above2: [],
        above3: [],
        below1: [],
        below2: [],
        below3: []
      };

      // Track number of offset cards per tier (for staggered L-connectors)
      const offsetCounts = {
        above1: 0,
        above2: 0,
        above3: 0,
        below1: 0,
        below2: 0,
        below3: 0
      };

      // Track placed range bars for stacking
      const placedRangeBars = [];
      const barHeight = 10;
      const barSpacing = 3;
      const firstBarOffset = 23;

      // Positioning log for debugging
      const positionLog = {
        events: [],
        tiers: { above1: [], above2: [], above3: [], below1: [], below2: [], below3: [] }
      };

      // Function to check if two range bars overlap horizontally
      function rangeBarsOverlap(bar1, bar2) {
        return !(bar1.x2 < bar2.x1 || bar2.x2 < bar1.x1);
      }

      // Function to find the stack level for a range bar
      function findRangeBarStackLevel(x1, x2) {
        let level = 0;
        let hasOverlap = true;

        while (hasOverlap) {
          hasOverlap = false;
          for (const placedBar of placedRangeBars) {
            if (placedBar.level === level && rangeBarsOverlap({ x1, x2 }, placedBar)) {
              hasOverlap = true;
              break;
            }
          }
          if (hasOverlap) {
            level++;
          }
        }
        return level;
      }

      // ============================================================================
      // CONSTRAINT-BASED RECURSIVE PLACEMENT ALGORITHM
      // ============================================================================

      console.log('\nüéØ Starting constraint-based placement algorithm...');

      // Constants for placement
      const FLEX_ZONE = CARD_WIDTH * 0.4; // 112px for 280px card

      // Separate point events from range events
      const pointEvents = viewportEvents.filter(e => e.type !== 'range');
      const rangeEvents = viewportEvents.filter(e => e.type === 'range');

      // Sort point events by natural X position
      pointEvents.sort((a, b) => a.x - b.x);

      console.log(`üìä Point events: ${pointEvents.length}, Range events: ${rangeEvents.length}`);

      // Calculate density on left vs right to choose direction
      function calculateDensity(events, direction, lookahead = 5) {
        if (events.length < 2) return 0;

        let startIdx = direction === 'left' ? 0 : events.length - 1;
        let step = direction === 'left' ? 1 : -1;
        let endIdx = Math.max(0, Math.min(events.length - 1, startIdx + (step * lookahead)));

        let totalGap = 0;
        let count = 0;
        for (let i = startIdx; i !== endIdx; i += step) {
          if (i + step < 0 || i + step >= events.length) break;
          totalGap += Math.abs(events[i + step].x - events[i].x);
          count++;
        }

        return count > 0 ? count / totalGap : 0; // cards per pixel
      }

      const leftDensity = calculateDensity(pointEvents, 'left');
      const rightDensity = calculateDensity(pointEvents, 'right');
      const direction = leftDensity > rightDensity ? 'right' : 'left'; // Start from sparse side

      console.log(`üìà Density: left=${leftDensity.toFixed(6)}, right=${rightDensity.toFixed(6)} ‚Üí Start from ${direction}`);

      // Track placed cards per tier
      const placedCardsByTier = {
        above1: [],
        above2: [],
        above3: [],
        below1: [],
        below2: [],
        below3: []
      };

      // Calculate constraints for a card on a specific tier
      function calculateConstraints(card, tier, placedCards) {
        // Start with timeline margins (same boundaries as timeline axis)
        // Cards respect same margins as timeline axis for visual consistency
        let leftCenterBoundary = margin.left;  // Align with timeline start
        let rightCenterBoundary = width - margin.right;  // Align with timeline end

        // Find constraints from already-placed cards on same tier
        const cardsOnTier = placedCards.filter(c => c.assignedTier === tier);

        // Enhanced logging for debugging
        const debugLog = cardsOnTier.length > 0;
        console.log(`    üîç [${tier}] Cards on tier: ${cardsOnTier.length} (checking ${placedCards.length} total placed)`);
        if (debugLog) {
          cardsOnTier.forEach(c => console.log(`       - Card at ${c.finalX.toFixed(0)} on ${c.assignedTier}`));
        }

        for (const placedCard of cardsOnTier) {
          if (placedCard.finalX < card.x) {
            // Card to the left - new card center must be to the right of its right edge + gap
            const newLeft = placedCard.finalX + CARD_WIDTH/2 + MIN_GAP + CARD_WIDTH/2;
            if (debugLog) console.log(`    üîç Left neighbor at ${placedCard.finalX.toFixed(0)} ‚Üí leftBoundary=${newLeft.toFixed(0)}`);
            leftCenterBoundary = Math.max(leftCenterBoundary, newLeft);
          } else {
            // Card to the right - new card center must be to the left of its left edge - gap
            const newRight = placedCard.finalX - CARD_WIDTH/2 - MIN_GAP - CARD_WIDTH/2;
            if (debugLog) console.log(`    üîç Right neighbor at ${placedCard.finalX.toFixed(0)} ‚Üí rightBoundary=${newRight.toFixed(0)}`);
            rightCenterBoundary = Math.min(rightCenterBoundary, newRight);
          }
        }

        // Calculate available space based ONLY on neighbor cards (physical fit)
        // Flex zone is checked SEPARATELY to determine L-connector status
        const availableCenterLeft = leftCenterBoundary;
        const availableCenterRight = rightCenterBoundary;
        const availableWidth = availableCenterRight - availableCenterLeft;

        // Flex zone boundaries (for L-connector determination, NOT for canFit)
        const flexLeft = card.x - FLEX_ZONE;
        const flexRight = card.x + FLEX_ZONE;

        if (debugLog) {
          console.log(`    üîç Neighbor boundaries: [${leftCenterBoundary.toFixed(0)}, ${rightCenterBoundary.toFixed(0)}] width=${availableWidth.toFixed(0)}px`);
          console.log(`    üîç Flex zone (for L-connector check): [${flexLeft.toFixed(0)}, ${flexRight.toFixed(0)}]`);
        }

        return {
          left: availableCenterLeft,
          right: availableCenterRight,
          width: availableWidth,
          canFit: availableWidth > 0, // Based on neighbor space only
          flexLeft: flexLeft,          // Return flex zone separately
          flexRight: flexRight,         // Return flex zone separately
          tier: tier
        };
      }

      // Try to place card WITH redistribution of existing cards on tier
      function tryPlaceWithRedistribution(newCard, tier, placedCards) {
        // Get all cards currently on this tier (EXCLUDING ANCHORS - they must stay fixed)
        const cardsOnTier = placedCards.filter(c =>
          c.assignedTier === tier &&
          !c.isAnchor  // Don't redistribute anchor cards
        );

        // All cards to arrange (existing + new), sorted by natural X
        const allCards = [...cardsOnTier, newCard].sort((a, b) => a.x - b.x);

        console.log(`    üîÑ Trying redistribution on ${tier} with ${allCards.length} cards (${cardsOnTier.length} existing + 1 new)`);

        // Try to pack all cards optimally within their flex zones
        const solution = findOptimalPositions(allCards, tier, placedCards);

        if (solution) {
          console.log(`    ‚úÖ Redistribution successful! Total offset: ${solution.totalOffset.toFixed(0)}px`);
          return {
            tier: tier,
            positions: solution.positions,
            usesLConnector: false,
            totalOffset: solution.totalOffset
          };
        }

        console.log(`    ‚ùå Redistribution failed - cards can't fit within flex zones`);
        return null;
      }

      // Find optimal positions for all cards on a tier (global redistribution)
      function findOptimalPositions(cards, tier, allPlacedCards) {
        const positions = [];
        let totalOffset = 0;

        // Get anchor cards on this tier as fixed constraints
        const anchorsOnTier = allPlacedCards.filter(c => c.assignedTier === tier && c.isAnchor);

        // Start with timeline margins (same boundaries as timeline axis)
        let leftBoundary = margin.left; // Align with timeline start
        let rightBoundary = width - margin.right; // Align with timeline end

        // If there's a left anchor on this tier, constrain left boundary
        const leftAnchor = anchorsOnTier.find(a => a.finalX < cards[0].x);
        if (leftAnchor) {
          leftBoundary = leftAnchor.finalX + CARD_WIDTH/2 + MIN_GAP + CARD_WIDTH/2;
          console.log(`      Left anchor at ${leftAnchor.finalX.toFixed(0)} ‚Üí leftBoundary=${leftBoundary.toFixed(0)}`);
        }

        // If there's a right anchor on this tier, constrain right boundary
        const rightAnchor = anchorsOnTier.find(a => a.finalX > cards[cards.length-1].x);
        if (rightAnchor) {
          rightBoundary = rightAnchor.finalX - CARD_WIDTH/2 - MIN_GAP - CARD_WIDTH/2;
          console.log(`      Right anchor at ${rightAnchor.finalX.toFixed(0)} ‚Üí rightBoundary=${rightBoundary.toFixed(0)}`);
        }

        // GLOBAL REDISTRIBUTION: Calculate optimal spacing for all cards together
        const n = cards.length;
        const availableSpace = rightBoundary - leftBoundary;
        // Required space is center-to-center distance from first to last card
        // For n cards, this is (n-1) gaps of (CARD_WIDTH + MIN_GAP) center-to-center
        const requiredSpace = (n - 1) * (CARD_WIDTH + MIN_GAP);

        console.log(`      Total space: available=${availableSpace.toFixed(0)}px, required=${requiredSpace.toFixed(0)}px (for ${n} card centers)`);

        // Check if cards can physically fit
        if (requiredSpace > availableSpace) {
          console.log(`      ‚úó Can't fit: need ${requiredSpace.toFixed(0)}px but only have ${availableSpace.toFixed(0)}px`);
          return null;
        }

        // Special case: single card - just place at natural position if within bounds
        if (n === 1) {
          const card = cards[0];
          const flexLeft = card.x - FLEX_ZONE;
          const flexRight = card.x + FLEX_ZONE;

          // Try natural position first
          let optimalPos = card.x;
          if (optimalPos < leftBoundary) optimalPos = leftBoundary;
          if (optimalPos > rightBoundary) optimalPos = rightBoundary;

          // Check if within flex zone
          if (optimalPos < flexLeft || optimalPos > flexRight) {
            console.log(`      ‚úó Single card: natural=${card.x.toFixed(0)} adjusted to ${optimalPos.toFixed(0)}, outside flex zone [${flexLeft.toFixed(0)}, ${flexRight.toFixed(0)}]`);
            return null;
          }

          const offset = Math.abs(optimalPos - card.x);
          console.log(`      ‚Üí Single card placed at ${optimalPos.toFixed(0)} (shift=${offset.toFixed(0)}px)`);

          return {
            positions: [{card: card, position: optimalPos, offset: offset}],
            totalOffset: offset
          };
        }

        // Multiple cards: Try natural positions first, only redistribute if overlaps exist

        // Step 1: Check if natural positions work
        let hasOverlap = false;
        for (let i = 0; i < n - 1; i++) {
          const gap = cards[i + 1].x - cards[i].x;
          const minGapNeeded = CARD_WIDTH + MIN_GAP;
          if (gap < minGapNeeded) {
            hasOverlap = true;
            console.log(`      Overlap detected: cards at ${cards[i].x.toFixed(0)} and ${cards[i+1].x.toFixed(0)} (gap=${gap.toFixed(0)}px, need=${minGapNeeded.toFixed(0)}px)`);
            break;
          }
        }

        // Step 2: If no overlaps, use natural positions
        if (!hasOverlap) {
          console.log(`      No overlaps - using natural positions`);
          for (let i = 0; i < n; i++) {
            const card = cards[i];
            const offset = 0;
            totalOffset += offset;

            positions.push({
              card: card,
              position: card.x,
              offset: offset
            });

            console.log(`      ‚Üí Card ${i} placed at natural ${card.x.toFixed(0)} (shift=0px)`);
          }
        } else {
          // Step 3: Overlaps exist - redistribute with MINIMUM spacing (keep group compact)
          // Use minimum spacing to keep cards as close to natural positions as possible
          const centerToCenterSpacing = CARD_WIDTH + MIN_GAP;  // 285px
          const redistributedSpan = (n - 1) * centerToCenterSpacing;

          console.log(`      Redistribution needed: using minimum spacing=${centerToCenterSpacing.toFixed(0)}px`);

          // Calculate group's natural span
          const naturalStart = cards[0].x;
          const naturalEnd = cards[n - 1].x;
          const naturalCentroid = (naturalStart + naturalEnd) / 2;

          // BOUNDARY-AWARE: Calculate start position that keeps all cards in bounds
          let redistributedStart = naturalCentroid - redistributedSpan / 2;

          // Clamp to ensure all cards stay within boundaries
          const minStart = leftBoundary;  // Leftmost card can't go left of this
          const maxStart = rightBoundary - redistributedSpan;  // Rightmost card can't go right

          if (redistributedStart < minStart) {
            console.log(`      Clamping redistributedStart from ${redistributedStart.toFixed(0)} to ${minStart.toFixed(0)} (left boundary)`);
            redistributedStart = minStart;
          } else if (redistributedStart > maxStart) {
            console.log(`      Clamping redistributedStart from ${redistributedStart.toFixed(0)} to ${maxStart.toFixed(0)} (right boundary)`);
            redistributedStart = maxStart;
          }

          console.log(`      Natural span: ${naturalStart.toFixed(0)}-${naturalEnd.toFixed(0)}, centroid=${naturalCentroid.toFixed(0)}`);

          // Find optimal position within clamped range that minimizes offset
          // Try to stay close to natural centroid while respecting boundaries
          let optimalStart = redistributedStart;
          let minTotalOffset = Infinity;

          // Sample a few positions around redistributedStart
          const samples = [
            redistributedStart,
            Math.max(minStart, redistributedStart - 50),
            Math.min(maxStart, redistributedStart + 50)
          ];

          for (const startPos of samples) {
            let sampleTotalOffset = 0;
            let valid = true;

            for (let i = 0; i < n; i++) {
              const pos = startPos + i * centerToCenterSpacing;
              const card = cards[i];
              const flexLeft = card.x - FLEX_ZONE;
              const flexRight = card.x + FLEX_ZONE;

              if (pos < flexLeft || pos > flexRight) {
                valid = false;
                break;
              }
              sampleTotalOffset += Math.abs(pos - card.x);
            }

            if (valid && sampleTotalOffset < minTotalOffset) {
              minTotalOffset = sampleTotalOffset;
              optimalStart = startPos;
            }
          }

          redistributedStart = optimalStart;
          console.log(`      Optimal start: ${redistributedStart.toFixed(0)} (total offset: ${minTotalOffset.toFixed(0)}px)`);

          // Place cards at optimal positions
          let currentPos = redistributedStart;
          for (let i = 0; i < n; i++) {
            const card = cards[i];
            const flexLeft = card.x - FLEX_ZONE;
            const flexRight = card.x + FLEX_ZONE;

            console.log(`      Card ${i}: natural=${card.x.toFixed(0)} flex=[${flexLeft.toFixed(0)}, ${flexRight.toFixed(0)}] redistributedPos=${currentPos.toFixed(0)}`);

            // Check if within flex zone and boundaries
            if (currentPos < flexLeft || currentPos > flexRight) {
              console.log(`      ‚úó Redistributed position ${currentPos.toFixed(0)} outside flex zone [${flexLeft.toFixed(0)}, ${flexRight.toFixed(0)}]`);
              return null;
            }
            if (currentPos < leftBoundary || currentPos > rightBoundary) {
              console.log(`      ‚úó Redistributed position ${currentPos.toFixed(0)} outside boundaries [${leftBoundary.toFixed(0)}, ${rightBoundary.toFixed(0)}]`);
              return null;
            }

            const offset = Math.abs(currentPos - card.x);
            totalOffset += offset;

            console.log(`      ‚Üí Placed at ${currentPos.toFixed(0)} (shift=${offset.toFixed(0)}px)`);

            positions.push({
              card: card,
              position: currentPos,
              offset: offset
            });

            currentPos += centerToCenterSpacing;
          }
        }

        return {
          positions: positions,
          totalOffset: totalOffset
        };
      }

      // Try to place a card on a specific tier (OLD METHOD - fallback only)
      function tryPlaceOnTier(card, tier, placedCards) {
        const constraints = calculateConstraints(card, tier, placedCards);

        if (!constraints.canFit) {
          console.log(`  ‚ùå Tier ${tier}: Can't fit (center range: ${constraints.width.toFixed(0)}px)`);
          return null;
        }

        // Optimal position for CENTER: closest to natural X within available space
        let optimalCenterX = card.x;
        if (optimalCenterX < constraints.left) optimalCenterX = constraints.left;
        if (optimalCenterX > constraints.right) optimalCenterX = constraints.right;

        const offset = optimalCenterX - card.x;

        // Check if final position is within flex zone (determines L-connector)
        const withinFlexZone = (optimalCenterX >= constraints.flexLeft &&
                                optimalCenterX <= constraints.flexRight);
        const usesLConnector = !withinFlexZone;

        console.log(`  ‚úÖ Tier ${tier}: Fits at centerX=${optimalCenterX.toFixed(0)} (offset=${offset.toFixed(0)}px, withinFlexZone=${withinFlexZone}, L-connector=${usesLConnector})`);

        return {
          tier: tier,
          finalX: optimalCenterX,
          offset: offset,
          usesLConnector: usesLConnector,
          constraints: constraints
        };
      }

      // Recursive placement function
      function placeCardRecursive(cardIdx, placedCards, endIdx) {
        if (cardIdx >= endIdx) {
          console.log('‚úÖ All middle cards placed!');
          return placedCards;
        }

        const card = pointEvents[cardIdx];
        const eventDate = d3.timeFormat('%b %d, %Y')(card.parsedDate);

        console.log(`\nüéØ Placing [${cardIdx}] "${card.text}" (${eventDate}) at naturalX=${card.x.toFixed(0)}`);

        // Determine tier order (zigzag pattern: above1, below1, above1, below1...)
        // Tier 3 (above3/below3) only used for "all events" filter
        const preferAbove = cardIdx % 2 === 0;
        const useTier3 = currentView === 'all';
        const tierOrder = preferAbove
          ? (useTier3 ? ['above1', 'below1', 'above2', 'below2', 'above3', 'below3']
                      : ['above1', 'below1', 'above2', 'below2'])
          : (useTier3 ? ['below1', 'above1', 'below2', 'above2', 'below3', 'above3']
                      : ['below1', 'above1', 'below2', 'above2']);

        console.log(`  üîÑ Zigzag preference: ${preferAbove ? 'above' : 'below'} (card ${cardIdx})`);

        // PASS 1: Try all tiers WITHOUT redistribution (prefer natural positions and zigzag)
        let bestLConnector = null;
        for (const tier of tierOrder) {
          const result = tryPlaceOnTier(card, tier, placedCards);

          if (result && !result.usesLConnector) {
            // Success! Card fits within flex zone at natural position
            card.assignedTier = tier;
            card.finalX = result.finalX;
            card.offset = result.offset;
            card.usesLConnector = false;

            placedCards.push(card);
            console.log(`  ‚ú® Placed on ${tier} within flex zone (no redistribution)`);

            // Recurse to next card
            return placeCardRecursive(cardIdx + 1, placedCards, endIdx);
          } else if (result && result.usesLConnector) {
            // Card fits but needs L-connector - save as backup
            console.log(`  ‚ö†Ô∏è  ${tier} would need L-connector`);
            if (!bestLConnector) {
              bestLConnector = result; // Save first L-connector option
            }
          }
        }

        // PASS 2: Try all tiers WITH redistribution (only if Pass 1 failed)
        console.log(`  üîÑ Pass 1 failed - trying redistribution on all tiers`);
        for (const tier of tierOrder) {
          const redistResult = tryPlaceWithRedistribution(card, tier, placedCards);

          if (redistResult) {
            // Success! Apply redistributions to all cards on tier
            console.log(`  ‚ú® Placed on ${tier} WITH redistribution`);

            // Update positions of existing cards on this tier
            for (const posInfo of redistResult.positions) {
              if (posInfo.card !== card) {
                // Update existing card's position
                posInfo.card.finalX = posInfo.position;
                posInfo.card.offset = posInfo.offset;
                const cardLeft = posInfo.position - CARD_WIDTH/2;
                const cardRight = posInfo.position + CARD_WIDTH/2;
                console.log(`    üìå Redistributed "${posInfo.card.text.substring(0, 30)}..." center=${posInfo.position.toFixed(0)} left=${cardLeft.toFixed(0)} right=${cardRight.toFixed(0)}`);
              } else {
                // Place new card
                card.assignedTier = tier;
                card.finalX = posInfo.position;
                card.offset = posInfo.offset;
                card.usesLConnector = false;
                const cardLeft = posInfo.position - CARD_WIDTH/2;
                const cardRight = posInfo.position + CARD_WIDTH/2;
                console.log(`    ‚ú® New card placed: center=${posInfo.position.toFixed(0)} left=${cardLeft.toFixed(0)} right=${cardRight.toFixed(0)}`);
              }
            }

            // Verify gaps after redistribution
            const sortedPositions = redistResult.positions.slice().sort((a, b) => a.position - b.position);
            for (let i = 0; i < sortedPositions.length - 1; i++) {
              const gap = (sortedPositions[i+1].position - CARD_WIDTH/2) - (sortedPositions[i].position + CARD_WIDTH/2);
              console.log(`    üîç Gap between cards: ${gap.toFixed(1)}px (min required: ${MIN_GAP}px) ${gap >= MIN_GAP ? '‚úì' : '‚úó OVERLAP!'}`);
            }

            placedCards.push(card);

            // Recurse to next card
            return placeCardRecursive(cardIdx + 1, placedCards, endIdx);
          }
        }

        // No tier worked within flex zone, use best L-connector result
        // This ensures we respect constraints and avoid collisions even with L-connector
        const fallbackTier = preferAbove ? 'above1' : 'below1';
        console.log(`  ‚ö†Ô∏è  No tier fits within flex zone - using L-connector on ${bestLConnector ? bestLConnector.tier : fallbackTier}`);
        const fallbackResult = bestLConnector || tryPlaceOnTier(card, fallbackTier, placedCards) || {
          tier: fallbackTier,
          finalX: card.x,
          offset: 0,
          usesLConnector: true
        };

        card.assignedTier = fallbackResult.tier;
        card.finalX = fallbackResult.finalX;
        card.offset = fallbackResult.offset;
        card.usesLConnector = true;

        placedCards.push(card);

        // Recurse to next card
        return placeCardRecursive(cardIdx + 1, placedCards, endIdx);
      }

      // Anchor end cards first
      if (pointEvents.length > 0) {
        console.log('\nüìç Anchoring end cards...');

        if (pointEvents.length === 1) {
          // Only one card - anchor it
          const singleCard = pointEvents[0];
          singleCard.assignedTier = 'above1';
          singleCard.finalX = singleCard.x;
          singleCard.offset = 0;
          singleCard.usesLConnector = false;
          console.log(`  üìç Single card: "${singleCard.text}" at X=${singleCard.x.toFixed(0)} on above1`);
        } else {
          // Left anchor
          const leftAnchor = pointEvents[0];
          leftAnchor.assignedTier = 'above1';
          leftAnchor.finalX = leftAnchor.x;
          leftAnchor.offset = 0;
          leftAnchor.usesLConnector = false;
          leftAnchor.isAnchor = true;  // Mark as anchor so it won't be redistributed
          console.log(`  üìç Left anchor: "${leftAnchor.text}" at X=${leftAnchor.x.toFixed(0)} on above1`);

          // Right anchor
          const rightAnchor = pointEvents[pointEvents.length - 1];
          rightAnchor.assignedTier = 'below1';
          rightAnchor.isAnchor = true;  // Mark as anchor so it won't be redistributed
          rightAnchor.finalX = rightAnchor.x;
          rightAnchor.offset = 0;
          rightAnchor.usesLConnector = false;
          console.log(`  üìç Right anchor: "${rightAnchor.text}" at X=${rightAnchor.x.toFixed(0)} on below1`);

          // Place middle cards recursively (skip anchors: start at 1, end at length-2)
          if (pointEvents.length > 2) {
            const anchoredCards = [leftAnchor, rightAnchor];
            const startIdx = 1;
            const endIdx = pointEvents.length - 1; // Stop before right anchor

            // Place middle cards with proper endIdx
            placeCardRecursive(startIdx, anchoredCards, endIdx);

            console.log('\nüìä Placement Summary:');
            const tierCounts = {};
            const lConnectorCount = pointEvents.filter(c => c.usesLConnector).length;

            for (const card of pointEvents) {
              tierCounts[card.assignedTier] = (tierCounts[card.assignedTier] || 0) + 1;
            }

            console.log(`  Tier distribution: ${JSON.stringify(tierCounts)}`);
            console.log(`  L-connectors used: ${lConnectorCount}`);
          } else {
            // Only 2 cards (both anchors)
            console.log('\nüìä Placement Summary:');
            console.log(`  Tier distribution: {"above1":1,"below1":1}`);
            console.log(`  L-connectors used: 0`);
          }
        }
      }

      // ============================================================================
      // END CONSTRAINT-BASED PLACEMENT
      // ============================================================================

      // Draw events
      viewportEvents.forEach((event, eventIndex) => {
        // Create unique ID for this event
        const eventId = `event-${eventIndex}`;
        event.eventId = eventId;
        if (event.type === 'range') {
          // Draw range as horizontal bar - always above timeline
          const x1 = event.x; // Use pre-calculated X position
          const x2 = xScale(event.parsedEndDate);

          // Find the appropriate stack level for this bar
          const stackLevel = findRangeBarStackLevel(x1, x2);

          // Calculate barY based on stack level
          // First bar: 23px above, subsequent bars stack with 3px spacing
          const barY = timelineY - (firstBarOffset + stackLevel * (barHeight + barSpacing));

          // Cycle through range bar colors for visual variety
          const barColorIndex = placedRangeBars.length % rangeBarColors.length;
          const barColor = rangeBarColors[barColorIndex];

          // Draw the bar
          svg.append('rect')
            .attr('class', `range-bar category-${event.category} priority-${event.priority || 'medium'}`)
            .attr('x', x1)
            .attr('y', barY - barHeight / 2)
            .attr('width', x2 - x1)
            .attr('height', barHeight)
            .attr('rx', 6)
            .attr('fill', barColor)
            .attr('stroke', barColor)
            .on('mouseover', (e) => showTooltip(e, event, e))
            .on('mousemove', (e) => moveTooltip(e))
            .on('mouseout', hideTooltip)
            .on('click', () => showSidePanel(event));

          // Track this bar for future overlap detection
          placedRangeBars.push({
            x1: x1,
            x2: x2,
            level: stackLevel
          });

        } else {
          // Point event - use pre-calculated position from constraint-based algorithm
          const x = event.x; // Natural X position
          const layer = event.assignedTier || 'above1'; // Use pre-calculated tier
          const offset = event.offset || 0; // Use pre-calculated offset
          const cardCenterX = event.finalX || (x + offset); // Use pre-calculated finalX

          const cardLeft = cardCenterX - CARD_WIDTH / 2;
          const cardRight = cardCenterX + CARD_WIDTH / 2;

          // Calculate flexible attachment point for connector line
          // Allow connection within 40% of card edges from center (112px each side)
          const FLEX_ZONE = CARD_WIDTH * 0.4; // 112px for 280px card
          let flexZoneLeft = cardCenterX - FLEX_ZONE;
          let flexZoneRight = cardCenterX + FLEX_ZONE;

          // Constrain flex zone to container bounds (prevent connectors from going outside timeline)
          const containerLeft = margin.left;
          const containerRight = width - margin.right;
          flexZoneLeft = Math.max(flexZoneLeft, containerLeft);
          flexZoneRight = Math.min(flexZoneRight, containerRight);

          // Constrain flex zone to chronological neighbors (prevent connector crossing)
          // Get previous and next point events (skip range events)
          const pointEvents = viewportEvents.filter(e => e.type !== 'range');
          const pointEventIndex = pointEvents.findIndex(e => e === event);

          if (pointEventIndex > 0) {
            const prevEvent = pointEvents[pointEventIndex - 1];
            // Don't attach left of previous event's dot
            flexZoneLeft = Math.max(flexZoneLeft, prevEvent.x);
          }

          if (pointEventIndex < pointEvents.length - 1) {
            const nextEvent = pointEvents[pointEventIndex + 1];
            // Don't attach right of next event's dot
            flexZoneRight = Math.min(flexZoneRight, nextEvent.x);
          }

          // Determine connector attachment X position
          let connectorAttachX;
          if (x >= flexZoneLeft && x <= flexZoneRight) {
            // Event dot is within flex zone - connect directly (no horizontal offset)
            connectorAttachX = x;
          } else if (x < flexZoneLeft) {
            // Event dot is left of flex zone - connect at left edge of zone
            connectorAttachX = flexZoneLeft;
          } else {
            // Event dot is right of flex zone - connect at right edge of zone
            connectorAttachX = flexZoneRight;
          }

          // Store in occupied layers (including eventX for batch redistribution and eventId for DOM updates)
          if (!occupiedLayers[layer]) occupiedLayers[layer] = [];
          occupiedLayers[layer].push({
            left: cardLeft,
            right: cardRight,
            centerX: cardCenterX,
            eventX: x,  // Store original event dot X position
            eventId: eventId  // Store eventId for DOM updates when applying adjustments
          });

          // Log positioning decision
          const logEntry = {
            id: event.id,
            text: event.text.substring(0, 40),
            naturalX: Math.round(x),
            layer: layer,
            offset: Math.round(offset),
            cardLeft: Math.round(cardLeft),
            cardRight: Math.round(cardRight),
            cardCenter: Math.round(cardCenterX),
            connectorX: Math.round(connectorAttachX),
            connectorOffset: Math.round(connectorAttachX - x),
            decision: offset === 0 && connectorAttachX === x ? 'straight' : 'L-shaped'
          };
          positionLog.events.push(logEntry);
          positionLog.tiers[layer].push(logEntry);

          // Determine Y position based on layer
          const isAbove = layer.startsWith('above');
          const layerDistance = LAYERS[layer];

          // Truncate description
          const desc = event.description.length > 120
            ? event.description.substring(0, 120) + '...'
            : event.description;

          // Strip <br> tags but keep <strong> for bold text in preview
          const previewDesc = desc.replace(/<br\s*\/?>/gi, ' ');

          // Create card at temporary position first
          const card = cardsContainer.append('div')
            .attr('class', `event-card category-${event.category}`)
            .attr('data-event-id', eventId)
            .style('left', cardLeft + 'px')
            .style('top', '0px')
            .on('click', function() {
              // Add highlight effect
              d3.select(this).classed('highlight', true);
              // Remove highlight after animation
              setTimeout(() => {
                d3.select(this).classed('highlight', false);
              }, 400);
              showSidePanel(event);
            })
            .on('mouseenter', function() {
              // Highlight card
              d3.select(this).classed('highlight', true);

              // Highlight connector lines
              svg.selectAll(`.connector-line[data-event-id="${eventId}"]`)
                .classed('highlighted', true)
                .attr('stroke', getEffectiveColor(event));

              // Highlight timeline dot
              svg.select(`.timeline-dot[data-event-id="${eventId}"]`)
                .classed('highlighted', true);
            })
            .on('mouseleave', function() {
              // Remove card highlight
              d3.select(this).classed('highlight', false);

              // Remove highlight from connector lines
              svg.selectAll(`.connector-line[data-event-id="${eventId}"]`)
                .classed('highlighted', false)
                .attr('stroke', '#666');

              // Remove highlight from timeline dot
              svg.select(`.timeline-dot[data-event-id="${eventId}"]`)
                .classed('highlighted', false);
            });

          // Date heading (colored)
          card.append('div')
            .attr('class', 'card-date')
            .style('color', getEffectiveColor(event))
            .text(d3.timeFormat('%b %d, %Y')(event.parsedDate));

          // Event title
          card.append('div')
            .attr('class', 'card-title')
            .text(event.text);

          // Description
          card.append('div')
            .attr('class', 'card-description')
            .html(previewDesc);


          // Measure actual card height
          const cardElement = card.node();
          const cardRect = cardElement.getBoundingClientRect();
          const measuredHeight = cardRect.height;

          // Calculate card position with mirror symmetry
          // Use measured height if valid, otherwise fallback to estimate
          const ESTIMATED_CARD_HEIGHT = 160;
          const cardHeight = (measuredHeight > 0) ? measuredHeight : ESTIMATED_CARD_HEIGHT;

          // Account for timeline-wrapper padding offset (100px)
          // SVG starts at padding offset, but cards-container starts at 0
          const PADDING_OFFSET = 100;

          let cardTopY;
          if (isAbove) {
            // Position so card bottom is at line endpoint
            cardTopY = timelineY - layerDistance - cardHeight + PADDING_OFFSET;
          } else {
            // Position so card top is at the line endpoint
            cardTopY = timelineY + layerDistance + PADDING_OFFSET;
          }

          // Update card position
          card.style('top', cardTopY + 'px');

          // Draw connector line: straight if connector attaches directly at event dot, L-shaped otherwise
          const cardEdgeY = isAbove ? (timelineY - layerDistance) : (timelineY + layerDistance);

          // Check if connector can attach directly at event dot (no horizontal offset needed)
          if (offset === 0 && connectorAttachX === x) {
            // No offset AND connector attaches at event dot - draw straight vertical line
            svg.append('line')
              .attr('class', 'connector-line')
              .attr('data-event-id', eventId)
              .attr('x1', x)
              .attr('y1', timelineY)
              .attr('x2', x)
              .attr('y2', cardEdgeY);
          } else {
            // Card has been offset OR needs horizontal connector to reach attachment point
            // Increment offset count for this tier (only if actually offset)
            if (offset !== 0) {
              offsetCounts[layer]++;
            }

            // Calculate staggered transition point
            // Base: 50% of distance, then stagger by 12px per offset card
            const baseMidpoint = timelineY + (isAbove ? -layerDistance/2 : layerDistance/2);
            const staggerAmount = 12; // pixels to stagger each L-connector
            const staggerDirection = offset > 0 ? 1 : -1; // stagger up/down based on offset direction
            const staggerCount = offset !== 0 ? offsetCounts[layer] : 0;
            const transitionY = baseMidpoint + (staggerCount * staggerAmount * staggerDirection);

            // Vertical segment: from timeline dot to transition point
            svg.append('line')
              .attr('class', 'connector-line')
              .attr('data-event-id', eventId)
              .attr('x1', x)
              .attr('y1', timelineY)
              .attr('x2', x)
              .attr('y2', transitionY);

            // Horizontal segment: from transition point to connector attachment X
            svg.append('line')
              .attr('class', 'connector-line')
              .attr('data-event-id', eventId)
              .attr('x1', x)
              .attr('y1', transitionY)
              .attr('x2', connectorAttachX)
              .attr('y2', transitionY);

            // Vertical segment: from horizontal line to card edge
            svg.append('line')
              .attr('class', 'connector-line')
              .attr('data-event-id', eventId)
              .attr('x1', connectorAttachX)
              .attr('y1', transitionY)
              .attr('x2', connectorAttachX)
              .attr('y2', cardEdgeY);
          }

          // Draw dot on timeline (on top of line)
          svg.append('circle')
            .attr('class', `timeline-dot category-${event.category} priority-${event.priority || 'medium'}`)
            .attr('data-event-id', eventId)
            .attr('cx', x)
            .attr('cy', timelineY)
            .attr('r', 10)
            .attr('fill', getEffectiveColor(event))
            .on('click', () => showSidePanel(event))
            .on('mouseenter', function() {
              // Highlight connector lines
              svg.selectAll(`.connector-line[data-event-id="${eventId}"]`)
                .classed('highlighted', true)
                .attr('stroke', getEffectiveColor(event));

              // Highlight timeline dot
              d3.select(this).classed('highlighted', true);

              // Highlight card
              cardsContainer.selectAll(`.event-card[data-event-id="${eventId}"]`)
                .classed('highlight', true);
            })
            .on('mouseleave', function() {
              // Remove highlight from connector lines
              svg.selectAll(`.connector-line[data-event-id="${eventId}"]`)
                .classed('highlighted', false)
                .attr('stroke', '#666');

              // Remove highlight from timeline dot
              d3.select(this).classed('highlighted', false);

              // Remove highlight from card
              cardsContainer.selectAll(`.event-card[data-event-id="${eventId}"]`)
                .classed('highlight', false);
            });
        }
      });

      // Output positioning log to console
      console.group('üìç Card Positioning Analysis');
      console.log(`Filter: ${currentView} | Total events: ${viewportEvents.length}`);
      console.table(positionLog.events);

      Object.keys(positionLog.tiers).forEach(tier => {
        if (positionLog.tiers[tier].length > 0) {
          console.group(`Tier: ${tier} (${positionLog.tiers[tier].length} cards)`);

          // Calculate gaps between adjacent cards
          const tierCards = positionLog.tiers[tier].sort((a, b) => a.cardLeft - b.cardLeft);
          const gaps = [];
          for (let i = 0; i < tierCards.length - 1; i++) {
            const gap = tierCards[i + 1].cardLeft - tierCards[i].cardRight;
            gaps.push({
              between: `${tierCards[i].id} ‚Üí ${tierCards[i + 1].id}`,
              gap: Math.round(gap),
              minRequired: MIN_GAP,
              status: gap >= MIN_GAP ? '‚úì OK' : '‚úó OVERLAP'
            });
          }

          if (gaps.length > 0) {
            console.log('Gaps between cards:');
            console.table(gaps);
          }

          console.table(tierCards);
          console.groupEnd();
        }
      });

      console.groupEnd();

      // Draw month markers AFTER all events (so labels appear on top of connector lines)
      monthMarkers.forEach((marker) => {
        const x = xScale(marker.date);

        // Only draw if within bounds
        if (x >= margin.left && x <= width - margin.right) {
          // Draw tick mark on timeline (theme-aware color)
          const tickColor = getComputedStyle(document.documentElement).getPropertyValue('--month-tick-color');
          svg.append('line')
            .attr('x1', x)
            .attr('y1', timelineY - 15)
            .attr('x2', x)
            .attr('y2', timelineY + 15)
            .attr('stroke', tickColor.trim())
            .attr('stroke-width', 2);

          // Add white background behind label
          const labelText = svg.append('text')
            .attr('class', 'date-label')
            .attr('x', x)
            .attr('y', timelineY + 40)
            .attr('text-anchor', 'middle')
            .text(marker.label);

          // Get text dimensions for background
          const textBBox = labelText.node().getBBox();

          // Insert background rectangle before text (uses theme color)
          const labelBg = getComputedStyle(document.documentElement).getPropertyValue('--month-label-bg');
          const bgHeight = textBBox.height + 4;  // Increased vertical padding
          const hPadding = 8;  // Horizontal padding (8px on each side)
          svg.insert('rect', '.date-label')
            .attr('x', textBBox.x - hPadding)
            .attr('y', textBBox.y - 2)
            .attr('width', textBBox.width + (hPadding * 2))
            .attr('height', bgHeight)
            .attr('rx', bgHeight / 2)  // Pill shape: border-radius = half height
            .attr('fill', labelBg.trim());

        }
      });
    }

    // Render mini-map
    function renderMiniMap() {
      const miniMapTimeline = document.getElementById('mini-map-timeline');
      const miniMapViewport = document.getElementById('mini-map-viewport');
      const miniMapContainer = document.getElementById('mini-map-container');
      const leftArrow = document.getElementById('nav-arrow-left');
      const rightArrow = document.getElementById('nav-arrow-right');

      // Show mini-map and navigation for all specialized filter views
      const showNavigation = (
        currentView === 'overview' ||
        currentView === 'family' ||
        currentView === 'disability' ||
        currentView === 'just-cause-failure' ||
        currentView === 'bad-faith-conduct' ||
        currentView === 'post-termination-misconduct' ||
        currentView === 'ohs'
      );

      if (!showNavigation || !fullTimelineStart || !fullTimelineEnd || allFilteredEvents.length === 0) {
        // Hide mini-map and navigation arrows
        miniMapContainer.style.display = 'none';
        leftArrow.style.display = 'none';
        rightArrow.style.display = 'none';
        return;
      }

      // Show mini-map and navigation arrows
      miniMapContainer.style.display = 'block';
      leftArrow.style.display = 'flex';
      rightArrow.style.display = 'flex';

      // Clear existing event dots
      const existingDots = miniMapTimeline.querySelectorAll('.mini-map-event');
      existingDots.forEach(dot => dot.remove());

      // Create scale for mini-map
      const miniMapWidth = miniMapTimeline.offsetWidth;
      const miniMapScale = d3.scaleTime()
        .domain([fullTimelineStart, fullTimelineEnd])
        .range([0, miniMapWidth]);

      // Draw all filtered events as dots
      allFilteredEvents.forEach(event => {
        const eventDate = event.parsedDate;
        const xPos = miniMapScale(eventDate);

        const dot = document.createElement('div');
        dot.className = 'mini-map-event';
        dot.style.left = xPos + 'px';
        dot.style.background = getEffectiveColor(event) || '#999';
        dot.title = event.text;

        // Click to jump to this event
        dot.addEventListener('click', () => {
          // Check if this is a single-day or multi-day event
          const isSingleDay = !event.parsedEndDate || event.parsedEndDate.getTime() === event.parsedDate.getTime();

          if (isSingleDay) {
            // For single-day events: find page based on position in singleDayEvents
            const sortedSingleDay = [...singleDayEvents].sort((a, b) => a.parsedDate - b.parsedDate);
            const eventIndex = sortedSingleDay.findIndex(e => e.id === event.id);

            if (eventIndex >= 0) {
              currentViewportIndex = Math.floor(eventIndex / eventsPerViewport);
            }
          } else {
            // For multi-day events: find first page that overlaps with this event
            const sortedSingleDay = [...singleDayEvents].sort((a, b) => a.parsedDate - b.parsedDate);
            const totalPages = Math.ceil(sortedSingleDay.length / eventsPerViewport);

            // Search each page to find first one that overlaps
            for (let pageIdx = 0; pageIdx < totalPages; pageIdx++) {
              const pageStart = pageIdx * eventsPerViewport;
              const pageEnd = Math.min(pageStart + eventsPerViewport, sortedSingleDay.length);
              const pageEvents = sortedSingleDay.slice(pageStart, pageEnd);

              if (pageEvents.length > 0) {
                const pageDates = [];
                pageEvents.forEach(e => {
                  pageDates.push(e.parsedDate);
                  if (e.parsedEndDate) pageDates.push(e.parsedEndDate);
                });
                const pageStartDate = d3.timeDay.offset(d3.min(pageDates), -1);
                const pageEndDate = d3.timeDay.offset(d3.max(pageDates), 1);

                // Check if multi-day event overlaps with this page
                if (event.parsedDate <= pageEndDate && event.parsedEndDate >= pageStartDate) {
                  currentViewportIndex = pageIdx;
                  break;
                }
              }
            }
          }

          // Update viewport dates for this page
          updateViewportDates(allFilteredEvents);
          updateNavigationButtons(allFilteredEvents);
          renderTimeline(allFilteredEvents);
          renderMiniMap();
        });

        miniMapTimeline.appendChild(dot);
      });

      // Update viewport indicator position and width
      const viewportStartX = miniMapScale(viewportStartDate);
      const viewportEndX = miniMapScale(viewportEndDate);
      const viewportWidth = viewportEndX - viewportStartX;

      miniMapViewport.style.left = viewportStartX + 'px';
      miniMapViewport.style.width = viewportWidth + 'px';

      // Set up draggable viewport (only once to prevent memory leak)
      if (!miniMapDragInitialized) {
        setupMiniMapDrag();
        miniMapDragInitialized = true;
      }
    }

    // Setup mini-map drag functionality (called once)
    function setupMiniMapDrag() {
      const miniMapViewport = document.getElementById('mini-map-viewport');
      let isDragging = false;
      let startX = 0;
      let startLeft = 0;

      miniMapViewport.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        startLeft = parseInt(miniMapViewport.style.left) || 0;
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const deltaX = e.clientX - startX;
        let newLeft = startLeft + deltaX;

        // Get current minimap dimensions
        const miniMapTimeline = document.getElementById('mini-map-timeline');
        const miniMapWidth = miniMapTimeline.offsetWidth;
        const viewportWidth = parseInt(miniMapViewport.style.width) || 0;

        // Clamp to minimap bounds
        if (newLeft < 0) newLeft = 0;
        if (newLeft + viewportWidth > miniMapWidth) {
          newLeft = miniMapWidth - viewportWidth;
        }

        // Calculate mini-map scale
        const miniMapScale = d3.scaleTime()
          .domain([fullTimelineStart, fullTimelineEnd])
          .range([0, miniMapWidth]);

        // Calculate new viewport dates from position
        const newStartDate = miniMapScale.invert(newLeft);
        const newEndDate = miniMapScale.invert(newLeft + viewportWidth);

        // Update viewport
        viewportStartDate = newStartDate;
        viewportEndDate = newEndDate;

        // Update visual immediately
        miniMapViewport.style.left = newLeft + 'px';
      });

      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          // Re-render timeline with new viewport
          updateNavigationButtons();
          renderTimeline(allFilteredEvents);
        }
      });
    }

    // Show side panel
    function showSidePanel(event) {
      const panel = document.getElementById('side-panel');
      const overlay = document.getElementById('panel-overlay');

      // Special case: Show timecard diagram for event ID 4 (Disciplinary Record 1A)
      if (event.id === 4) {
        showDiagramModal();
      }

      // Set header
      document.getElementById('panel-title').textContent = event.text;

      const dateStr = event.type === 'range'
        ? `${d3.timeFormat('%B %d, %Y')(event.parsedDate)} - ${d3.timeFormat('%B %d, %Y')(event.parsedEndDate)}`
        : d3.timeFormat('%B %d, %Y')(event.parsedDate);
      document.getElementById('panel-date').textContent = dateStr;

      const categoryBadge = document.getElementById('panel-category');
      categoryBadge.textContent = categoryLabels[event.category];
      categoryBadge.style.backgroundColor = getEffectiveColor(event);

      // Set content
      let content = '';

      // Add tag badges section
      if (event.tags && event.tags.length > 0) {
        content += `
          <div class="panel-section">
            <div class="card-tags">
              ${event.tags.map(tag => `<span class="tag-badge tag-${tag}">${tag.replace(/-/g, ' ')}</span>`).join('')}
            </div>
          </div>
        `;
      }

      content += `
        <div class="panel-section">
          <h3>Description</h3>
          <p>${event.description}</p>
        </div>
      `;

      if (event.evidence && event.evidence.length > 0) {
        content += `
          <div class="panel-section">
            <h3>Evidence</h3>
            <ul>
              ${event.evidence.map(e => `<li>${e}</li>`).join('')}
            </ul>
          </div>
        `;
      }

      if (event.witnesses && event.witnesses.length > 0) {
        content += `
          <div class="panel-section">
            <h3>Witnesses</h3>
            <ul>
              ${event.witnesses.map(w => `<li>${w}</li>`).join('')}
            </ul>
          </div>
        `;
      }

      // Evidence Images Section
      if (event.evidenceImages && event.evidenceImages.length > 0) {
        content += `<div class="panel-section evidence-images">`;

        event.evidenceImages.forEach((img, index) => {
          const isClickable = img.type === 'doc' || img.type === 'photo' || img.type === 'email';
          const clickClass = isClickable ? 'clickable' : '';
          const clickAttr = isClickable ? `data-img-index="${index}"` : '';

          // Determine size based on type
          let maxWidth = '300px'; // default for text/maps
          let maxHeight = '600px'; // default
          if (img.type === 'doc') {
            maxWidth = '300px';
            maxHeight = '600px';
          }
          if (img.type === 'photo') {
            maxWidth = '400px';
            maxHeight = '600px';
          }
          if (img.type === 'email') {
            maxWidth = '650px'; // Almost full width of 720px panel
            maxHeight = '1000px'; // Much taller for email readability
          }

          // Check if this is a PDF file - render as button-like container
          const isPdf = img.file.toLowerCase().endsWith('.pdf');

          if (isPdf) {
            // Extract filename without extension for button label
            const filename = img.file.split('/').pop();
            const nameWithoutExt = filename.replace('.pdf', '');
            let buttonLabel = nameWithoutExt;
            if (buttonLabel.includes('-2025')) {
              buttonLabel = buttonLabel.replace('-2025', '').replace(/-/g, ' ');
            } else if (buttonLabel.includes('-')) {
              buttonLabel = buttonLabel.replace(/-/g, ' ');
            }

            content += `
              <div class="evidence-image-container">
                <button
                  class="pdf-button ${clickClass}"
                  ${clickAttr}
                  style="padding: 12px 16px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; font-size: 14px; color: var(--text-primary); transition: all 0.2s; display: flex; align-items: center; gap: 8px;"
                  onmouseover="this.style.background='var(--btn-hover-bg)'; this.style.borderColor='var(--border-hover)';"
                  onmouseout="this.style.background='var(--bg-secondary)'; this.style.borderColor='var(--border-color)';"
                >
                  <span style="font-size: 16px;">üìÑ</span>
                  <span>${buttonLabel}</span>
                </button>
                ${img.caption ? `<p class="evidence-caption">${img.caption}</p>` : ''}
              </div>
            `;
          } else {
            // Regular image rendering
            content += `
              <div class="evidence-image-container">
                <img
                  src="${img.file}"
                  alt="${img.caption || 'Evidence'}"
                  class="evidence-image ${clickClass}"
                  style="max-width: ${maxWidth}; max-height: ${maxHeight};"
                  ${clickAttr}
                />
                ${img.caption ? `<p class="evidence-caption">${img.caption}</p>` : ''}
              </div>
            `;
          }
        });

        content += `</div>`;
      }

      if (event.legalSignificance) {
        content += `
          <div class="panel-section legal-significance">
            <h3>Legal Significance</h3>
            <p>${event.legalSignificance}</p>
          </div>
        `;
      }

      document.getElementById('panel-content').innerHTML = content;

      // Add event listeners to clickable items (images, buttons, etc)
      if (event.evidenceImages && event.evidenceImages.length > 0) {
        setTimeout(() => {
          // Handle all clickable elements
          const clickableElements = document.querySelectorAll('[data-img-index]');
          clickableElements.forEach(element => {
            element.addEventListener('click', function() {
              const index = parseInt(this.getAttribute('data-img-index'));
              const imgData = event.evidenceImages[index];
              showImageModal(imgData);
            });
          });
        }, 0);
      }

      // Show panel
      panel.classList.add('open');
      overlay.classList.add('visible');
    }

    // Show image modal (side-by-side)
    function showImageModal(imgData) {
      const imageModal = document.getElementById('image-modal');
      const imageModalContent = document.getElementById('image-modal-content');
      const imageModalTitle = document.getElementById('image-modal-title');
      const sidePanel = document.getElementById('side-panel');

      // Set title
      imageModalTitle.textContent = imgData.caption || 'Evidence Image';

      // Check if file is PDF
      const isPDF = imgData.file.toLowerCase().endsWith('.pdf');

      if (isPDF) {
        // Render PDF with iframe for maximum compatibility
        imageModalContent.innerHTML = `
          <iframe
            src="${imgData.file}#toolbar=0"
            type="application/pdf"
            width="100%"
            height="800px"
            style="border: none; margin-bottom: 10px;"
            title="${imgData.caption || 'PDF Evidence Document'}"
          ></iframe>
          ${imgData.caption ? `<p class="evidence-caption">${imgData.caption}</p>` : ''}
          <p style="font-size: 12px; color: #666; text-align: center;">
            <a href="${imgData.file}" target="_blank" style="color: #007bff; text-decoration: none;">
              üìÑ Open PDF in new tab
            </a>
          </p>
        `;
      } else {
        // Render image normally
        imageModalContent.innerHTML = `
          <img src="${imgData.file}" alt="${imgData.caption || 'Evidence'}" />
          ${imgData.caption ? `<p class="evidence-caption">${imgData.caption}</p>` : ''}
        `;
      }

      // Show image modal (no shift needed - modal is centered)
      imageModal.classList.add('open');
    }

    // Hide image modal
    function hideImageModal() {
      const imageModal = document.getElementById('image-modal');
      imageModal.classList.remove('open');
    }

    // Hide side panel
    function hideSidePanel() {
      hideImageModal(); // Close image modal if open
      document.getElementById('side-panel').classList.remove('open');
      document.getElementById('panel-overlay').classList.remove('visible');
    }

    // Setup panel listeners
    function setupPanelListeners() {
      document.getElementById('panel-overlay').addEventListener('click', hideSidePanel);
      document.getElementById('image-modal-close').addEventListener('click', hideImageModal);
    }

    // Setup timecard viewer
    function setupTimecardViewer() {
      const timecardToggle = document.getElementById('timecard-toggle');
      const timecardModal = document.getElementById('timecard-modal');
      const timecardClose = document.getElementById('timecard-close');
      const timecardContent = document.getElementById('timecard-content');

      // Timecard image filenames (Jan-Aug 2025)
      const timecardFiles = [
        'Timecard-Jan-2025.png',
        'Timecard-Feb-2025.png',
        'Timecard-Mar-2025.png',
        'Timecard-Apr-2025.png',
        'Timecard-May-2025.png',
        'Timecard-Jun-2025.png',
        'Timecard-July-2025.png',
        'Timecard-Aug-2025.png'
      ];

      // Open timecard viewer
      timecardToggle.addEventListener('click', () => {
        // Populate with timecard images
        timecardContent.innerHTML = timecardFiles.map(file =>
          `<img src="images/evidence/timecards/${file}" alt="${file}" class="timecard-image" />`
        ).join('');

        timecardModal.classList.add('open');
      });

      // Close timecard viewer
      timecardClose.addEventListener('click', () => {
        timecardModal.classList.remove('open');
      });

      // Close on outside click
      timecardModal.addEventListener('click', (e) => {
        if (e.target === timecardModal) {
          timecardModal.classList.remove('open');
        }
      });
    }

    // Setup and draw timecard system diagram
    function drawTimecardDiagram() {
      const canvas = document.getElementById('diagram-canvas');
      const ctx = canvas.getContext('2d');

      // Set canvas size (responsive)
      const width = Math.min(840, window.innerWidth - 100);
      const height = 1100;
      canvas.width = width;
      canvas.height = height;

      // Check if dark mode
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#e0e0e0' : '#333';
      const bgColor = isDark ? '#3a3a3a' : '#ffffff';
      const boxColor = isDark ? '#2b2b2b' : '#f8f9fa';
      const borderColor = isDark ? '#555' : '#ddd';
      const arrowColor = isDark ? '#999' : '#666';
      const warningColor = '#e74c3c';
      const lockColor = '#e67e22';

      // Clear canvas
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, width, height);

      // Helper: Draw rounded box
      function drawBox(x, y, w, h, text, subtext = '', color = boxColor, icon = '') {
        ctx.fillStyle = color;
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, 8);
        ctx.fill();
        ctx.stroke();

        // Icon
        if (icon) {
          ctx.font = 'bold 20px Arial';
          ctx.fillStyle = textColor;
          ctx.textAlign = 'left';
          ctx.fillText(icon, x + 12, y + 30);
        }

        // Main text
        ctx.font = 'bold 15px Roboto, Arial';
        ctx.fillStyle = textColor;
        ctx.textAlign = 'center';
        const lines = text.split('\n');
        lines.forEach((line, i) => {
          ctx.fillText(line, x + w/2, y + (icon ? 40 : 30) + (i * 20));
        });

        // Subtext
        if (subtext) {
          ctx.font = '12px Roboto, Arial';
          ctx.fillStyle = isDark ? '#b0b0b0' : '#666';
          ctx.fillText(subtext, x + w/2, y + (icon ? 40 : 30) + (lines.length * 20) + 8);
        }
      }

      // Helper: Draw arrow
      function drawArrow(x1, y1, x2, y2, color = arrowColor) {
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 3;

        // Line
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // Arrowhead
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const headlen = 12;
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI/6), y2 - headlen * Math.sin(angle - Math.PI/6));
        ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI/6), y2 - headlen * Math.sin(angle + Math.PI/6));
        ctx.closePath();
        ctx.fill();
      }

      const boxWidth = 600;
      const boxHeight = 70;
      const centerX = width / 2;
      const startY = 30;
      let currentY = startY;

      // Step 1: Work shift
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'EMPLOYEE WORKS SHIFT', '7:30 AM - 4:30 PM', boxColor, 'üë∑');
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, arrowColor);
      currentY += 15;

      // Step 2: Cannot submit during work
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'CANNOT SUBMIT DURING WORK ‚ùå', 'Must wait until AFTER shift ends', '#ffe5e5');
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, arrowColor);
      currentY += 15;

      // Step 3: Goes home - unpaid time
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'GOES HOME - UNPAID TIME üí∞', 'Must remember on own time', boxColor);
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, arrowColor);
      currentY += 15;

      // Step 4: Forgets?
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'FORGETS?', '', boxColor, '‚ùì');
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, arrowColor);
      currentY += 15;

      // Step 5: Automatic lockout
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'AUTOMATIC LOCKOUT: 3 DAYS üîí', 'System locks timecard', '#fff3cd', '‚ö†Ô∏è');
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, lockColor);
      currentY += 15;

      // Step 6: Cascading failure
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'CASCADING FAILURE', 'ONE locked card blocks ALL future submissions', '#ffe5e5');
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, lockColor);
      currentY += 15;

      // Step 7: Request unlock from boss
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'REQUEST UNLOCK FROM BOSS üìß', 'Only Boss can unlock', boxColor);
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, arrowColor);
      currentY += 15;

      // Step 8: Boss delays
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'BOSS DELAYS: DAYS, NOT HOURS ‚è±Ô∏è', 'Boss forgets, takes days to unlock', '#fff3cd', '‚è≥');
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, warningColor);
      currentY += 15;

      // Step 9: Misses payroll deadline
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'MISSES PAYROLL DEADLINE üí∏', 'Boss\'s delay pushes past cutoff', '#ffe5e5');
      currentY += boxHeight + 30;
      drawArrow(centerX, currentY - 25, centerX, currentY + 5, warningColor);
      currentY += 15;

      // Step 10: Employee gets disciplined
      drawBox(centerX - boxWidth/2, currentY, boxWidth, boxHeight,
        'EMPLOYEE GETS DISCIPLINED üìã', 'Blamed for Boss\'s delays', '#ffe5e5');
      currentY += boxHeight + 30;

      // Draw loop arrow back to top
      ctx.strokeStyle = warningColor;
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.moveTo(centerX, currentY - 10);
      ctx.lineTo(centerX + 320, currentY - 10);
      ctx.lineTo(centerX + 320, startY + boxHeight/2);
      ctx.lineTo(centerX + boxWidth/2 + 10, startY + boxHeight/2);
      ctx.stroke();
      ctx.setLineDash([]);

      // "LOOP REPEATS" text
      ctx.font = 'bold 14px Roboto, Arial';
      ctx.fillStyle = warningColor;
      ctx.textAlign = 'center';
      ctx.fillText('[LOOP REPEATS]', centerX + 240, currentY + 10);

      // Bottom irony box
      currentY += 50;
      const ironyBoxHeight = 120;
      ctx.fillStyle = isDark ? '#2d2d2d' : '#f0f7ff';
      ctx.strokeStyle = '#3498db';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(centerX - boxWidth/2, currentY, boxWidth, ironyBoxHeight, 8);
      ctx.fill();
      ctx.stroke();

      ctx.font = 'bold 16px Roboto, Arial';
      ctx.fillStyle = '#3498db';
      ctx.textAlign = 'center';
      ctx.fillText('THE IRONY:', centerX, currentY + 30);

      ctx.font = '13px Roboto, Arial';
      ctx.fillStyle = textColor;
      ctx.textAlign = 'left';
      const ironyPoints = [
        '‚Ä¢ Boss "notoriously bad" at timecards',
        '‚Ä¢ Boss was written up himself',
        '‚Ä¢ Boss took manager job "so he would never have to do',
        '  time cards ever again"',
        '‚Ä¢ Boss then disciplined Employee for same issue'
      ];
      ironyPoints.forEach((point, i) => {
        ctx.fillText(point, centerX - boxWidth/2 + 20, currentY + 55 + (i * 16));
      });
    }

    function showDiagramModal() {
      const modal = document.getElementById('diagram-modal');
      modal.classList.add('open');
      drawTimecardDiagram();
    }

    function hideDiagramModal() {
      const modal = document.getElementById('diagram-modal');
      modal.classList.remove('open');
    }

    function setupDiagramModal() {
      const diagramClose = document.getElementById('diagram-close');
      const diagramModal = document.getElementById('diagram-modal');

      // Close button
      diagramClose.addEventListener('click', hideDiagramModal);

      // Close on outside click
      diagramModal.addEventListener('click', (e) => {
        if (e.target === diagramModal) {
          hideDiagramModal();
        }
      });

      // Redraw on theme change
      window.addEventListener('themeChanged', () => {
        if (diagramModal.classList.contains('open')) {
          drawTimecardDiagram();
        }
      });
    }

    // Initialize on load (waits for both DOM and data.js)
    document.addEventListener('DOMContentLoaded', function() {
      domReady = true;
      tryInit();
    });
  </script>
</body>
</html>
